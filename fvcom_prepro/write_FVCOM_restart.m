function write_FVCOM_restart(fv_restart, out_restart, indata, out_date,inputConf,replace_vars)
% Duplicate an FVCOM restart file, replacing variable values with those
% specified in the struct data. 
% 
% function write_FVCOM_restart(fv_restart, out_restart, indata, out_date,...
%   inputConf, replace_vars)
% 
% DESCRIPTION:
%   Use an existing FVCOM restart file as a template, export all existing
%   data except for variables whose names match the data in the structs
%   'data' or 'replace_vars'. 
% 
% INPUT:
%   fv_restart  = full path to an existing FVCOM restart file.
%   out_restart = full path to the restart file to be created.
%   indata      = struct whose field names are the variable names to be
%       replaced.
%   out_date    = reset the restart file times to this time series
%       ([YYYY, MM, DD, HH, MM, SS] * number of timesteps).
%   inputConf = struct generated by create_files_*.m script. If restart
%       file data is to be cropped to the out_date time series (as opposed to
%       ramped from the input example restart file), then inputConf.crop =
%       true. Otherwise the field inputConf.crop need not exist.
%   replace_vars = [optional] Structure containing a list of variables
%       (replace_vars.varlist) to be replaced with specified values 
%       (replace_vars.value) in the output file.
% 
% OUTPUT:
%   FVCOM restart file.
% 
% EXAMPLE USAGE:
%   indata.temp = interpolated_temp;
%   indata.salinity = interpolated_salinity;
%   write_FVCOM_restart('/tmp/fvcom_restart.nc', ...
%       '/tmp/fvcom_restart_interp.nc', indata, inputConf.startDate,...
%           inputConf)
% 
% Author(s):
%   Pierre Cazenave (Plymouth Marine Laboratory)
%   Karen Amoudry (National Oceanography Centre, Liverpool
% 
% Revision history:
%   2013-02-08 First version.
%   2013-02-15 Fix bug wherein only the last field in the new data would
%   only be added to the output NetCDF file.
%   2013-03-13 Make the time rewriting optional and not just commented out.
%
% KJA Revision history:
%   2014-01-23 Add functionality to specify length of time series in output
%   file.
%   2014-01-31 Add functionality to replace user-specified variables in the
%   output file with user-specified constant values.
% 
%==========================================================================

subname = 'write_FVCOM_restart';
%%
global ftbverbose
if ftbverbose
    fprintf('\n')
    fprintf(['begin : ' subname '\n'])
end

% Get the fieldnames which must match the variable names to be replaced
% (case sensitive).
fnames = fieldnames(indata);
nf = length(fnames);

% Do we have a time series for the output data? And do we want to crop the
% output data to this time series?
if(isfield(inputConf,'crop'))
    % If only one output time point has been specified, bracket it
    if (size(out_date,1) == 1)
        temp_date = [datenum(out_date(1), out_date(2), out_date(3), out_date(4), out_date(5)-30, out_date(6));...
            datenum(out_date(1), out_date(2), out_date(3), out_date(4), out_date(5), out_date(6));...
            datenum(out_date(1), out_date(2), out_date(3), out_date(4), out_date(5)+30, out_date(6))];
        out_date = datevec(temp_date);
        
        % Replicate the output data
        for ii = 1:nf
            % If it's not a time variable
            if (size(strfind(fnames{ii},'time'))==0) & (size(strfind(fnames{ii},'Time'))==0)
                indata.(fnames{ii}) = repmat(indata.(fnames{ii}),...
                    [ones(ndims(indata.(fnames{ii})),1);3]);
            end
        end
    end
    
    % Set a value for the output NetCDF time dimension
    timedim = size(out_date,1);
end;

nc = netcdf.open(fv_restart, 'NOWRITE');
ncout = netcdf.create(out_restart, 'clobber');

[numdims, numvars, numglobatts, unlimdimID] = netcdf.inq(nc);

% Define the dimensions for all variables.
dimid = nan(numdims, 1);
dimnames = cell(numdims, 1);
dimlengths = nan(numdims, 1);
for ii = 1:numdims
    [dimname, dimlen] = netcdf.inqDim(nc, ii - 1);
    if ii ~= unlimdimID + 1 % NetCDF indices start at zero
        dimid(ii) = netcdf.defDim(ncout, dimname, dimlen);
    else
        if isfield(inputConf,'crop')
            dimlen = timedim;
        end
        dimid(ii) = netcdf.defDim(ncout, dimname, netcdf.getConstant('NC_UNLIMITED'));
    end
    dimnames{ii} = dimname;
    dimlengths(ii) = dimlen;
end


% Now define the variables and attributes.
for ii = 1:numvars

    % Find name of the current variable.
    [varname, xtype, varDimIDs, varAtts] = netcdf.inqVar(nc, ii - 1);

    % Create the variables.
    varid = netcdf.defVar(ncout, varname, xtype, varDimIDs);

    % Get each attribute and add it to the current variable.
    for j = 1:varAtts

        attname = netcdf.inqAttName(nc, varid, j - 1);
        attval = netcdf.getAtt(nc, varid, attname);

        netcdf.putAtt(ncout, varid, attname, attval);
    end
end

% Do the global attributes
for ii = 1:numglobatts
    
    % Find the current global attribute's name and value.
    gattname = netcdf.inqAttName(nc, netcdf.getConstant('NC_GLOBAL'), ii - 1);
    gattval = netcdf.getAtt(nc, netcdf.getConstant('NC_GLOBAL'), gattname);
    
    % Put that back into the output NetCDF file.
    netcdf.putAtt(ncout, netcdf.getConstant('NC_GLOBAL'), gattname, gattval);
end

netcdf.endDef(ncout);

% Get the existing data and output to the new NetCDF file, except for
% variables which match the fieldnames in the data struct.
for ii = 1:numvars
% for ii = 1:10
    [varname, ~, varDimIDs, ~] = netcdf.inqVar(nc, ii - 1);
    varid = netcdf.inqVarID(nc, varname);
    
%     fprintf(['Processing ',varname,'\n'])

    if ftbverbose
        fprintf('\tvariable %s... ', varname)
    end

    % Get the size of the data and the dimension names.
    currDimsNames = dimnames(varDimIDs + 1);
    currDimsLengths = dimlengths(varDimIDs + 1);

    % Find whether we've got an unlimited dimension in this data.
    wasUnlimited = -1;
    for jj = varDimIDs
        if numel(unlimdimID) > 1
            error('Do not currently support multiple unlimited dimensions.')
        end
        if strcmpi(dimnames(jj + 1), dimnames(unlimdimID + 1))
            wasUnlimited = jj;
        end
    end
    
    % Since the restart file has a number of time values, we can choose to
    % ramp up the replacement data from the existing start condition to the
    % actual value over the time steps. So, we need to know how many time
    % steps we actually have.

    % Get the dimension data ready for the replacement arrays.
    tIdx = strncmp(dimnames(unlimdimID + 1), currDimsNames, length(dimnames{unlimdimID + 1}));
    % Not sure about the hardcoded strings below...
    sIdx = strncmp('siglay', currDimsNames, length(dimnames{unlimdimID + 1}));
    nIdx = strncmp('node', currDimsNames, length(dimnames{unlimdimID + 1}));
    nt = currDimsLengths(tIdx);
    ns = currDimsLengths(sIdx);
    nd = currDimsLengths(nIdx);
    
    % Iterate through the field names to see if we're on one of the
    % variables to be replaced.

    % Set variable so we know if we've already written this variable to the
    % output file.
    writtenAlready = 0;
    for vv = 1:nf
        % If this is a variable we are replacing...
        if strcmp(varname, fnames{vv}) && writtenAlready == 0
            if ftbverbose
                fprintf('new data... ')
            end
            % Are we scaling this data with the POLCOMS data?
            if ~isfield(inputConf,'crop')
                % Grab the data
                data = netcdf.getVar(nc, varid);
                
                % To make the scaling go from the initial value to the POLCOMS
                % value, we need to scale the difference between the end
                % members by the scaling factor at each time and add to the
                % current time's value.
                sfvdata = nan(nd, ns, nt);
                ss = 0:1 / (nt - 1):1; % scale from 0 to 1.
                startdata = squeeze(data(:, :, 1)); % use the first modelled time step
                for tt = 1:nt
                    if tt == 1
                        sfvdata(:, :, 1) = startdata;
                    else
                        td = indata.(fnames{vv}) - startdata;
                        sfvdata(:, :, tt) = startdata + (ss(tt) .* td);
                    end
                end
                % Replace the values with the scaled interpolated values,
                % checking for unlimited dimensions as we go.
                if wasUnlimited < 0
                    netcdf.putVar(ncout, varid, sfvdata)
                else
                    netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, sfvdata)
                end
            else
                % Write the input data to the restart file, checking for
                % unlimited dimensions as we go.
                if wasUnlimited < 0
                    netcdf.putVar(ncout, varid, indata.(fnames{vv}))
                else
                    netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, indata.(fnames{vv}))
                end
            end

            writtenAlready = 1;

        % We might also want to replace the time. If so, supply a fourth
        % argument (out_date) to replace the times in the existing
        % restart file with an arbitrary time period.
        elseif strcmpi(varname, 'time') && writtenAlready == 0 && exist('out_date','var')
            if ftbverbose
                fprintf('new data... ')
            end

			if isfield(inputConf,'crop')
                for pp = 1:nt
                    tmp_time(pp) = greg2mjulian(out_date(pp,1), out_date(pp,2),...
                        out_date(pp,3), out_date(pp,4), out_date(pp,5), out_date(pp,6));
                end
			else
                tmp_start_time = greg2mjulian(out_date(1), out_date(2), out_date(3) - 7, out_date(4), out_date(5), out_date(6));
                tmp_time = tmp_start_time:(tmp_start_time + nt - 1);
			end
            netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, tmp_time)
            writtenAlready = 1;

        elseif strcmpi(varname, 'Times') && writtenAlready == 0 && exist('out_date','var')
            if ftbverbose
                fprintf('new data... ')
            end
            tmp_time = [];
            for i = 1:nt;
				if isfield(inputConf,'crop')
                	tmp_time = [tmp_time, sprintf('%-026s', datestr(datenum(out_date(i,:)), 'yyyy-mm-dd HH:MM:SS.FFF'))];
				else
					tmp_time = [tmp_time, sprintf('%-026s', datestr(datenum(start_date) - 7 + (i - 1), 'yyyy-mm-dd HH:MM:SS.FFF'))];
				end
            end
            netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, tmp_time)

            writtenAlready = 1;

        elseif strcmpi(varname, 'Itime') && writtenAlready == 0 && exist('out_date','var')
            if ftbverbose
                fprintf('new data... ')
            end

			if isfield(inputConf,'crop')
            	for pp = 1:nt
                	tmp_time(pp) = greg2mjulian(out_date(pp,1), out_date(pp,2),...
                	    out_date(pp,3), out_date(pp,4), out_date(pp,5), out_date(pp,6));
	            end
			else
	             tmp_start_time = greg2mjulian(out_date(1), out_date(2), out_date(3) - 7, out_date(4), out_date(5), out_date(6));
	             tmp_time = tmp_start_time:(tmp_start_time + nt - 1);
			end
             netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, floor(tmp_time))

            writtenAlready = 1;
            
        elseif strcmpi(varname, 'Itime2') && writtenAlready == 0 && exist('out_date','var')
            if ftbverbose
                fprintf('new data... ')
            end

			if isfield(inputConf,'crop')
            	for pp = 1:nt
            	    tmp_time(pp) = greg2mjulian(out_date(pp,1), out_date(pp,2),...
             	       out_date(pp,3), out_date(pp,4), out_date(pp,5), out_date(pp,6));
           		end
			else
				tmp_start_time = greg2mjulian(out_date(1), out_date(2), out_date(3) - 7, out_date(4), out_date(5), out_date(6));
				tmp_time = tmp_start_time:(tmp_start_time + nt - 1);
			end

            netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1),...
                currDimsLengths, round((mod(tmp_time,1)*24*3600*1000)/(3600*1000))*(3600*1000));
            
            writtenAlready = 1;

        end
    end

    % Is this a variable we're replacing with a specified value?
    if (writtenAlready == 0) && exist('replace_vars','var')
        if ftbverbose
            fprintf('existing data... ')
        end
        for vv = 1:size(replace_vars.varlist,1)
            if strcmp(varname, replace_vars.varlist{vv})
                % If the input data is a scalar, tile it to match the
                % required output size. If input is a single timestep and
                % the output requires more, tile it to match the required
                % output size.
                if isscalar(replace_vars.value{vv})
                    outdata = repmat(replace_vars.value{vv}, currDimsLengths');
                elseif (wasUnlimited > 0) && (ndims(replace_vars.value{vv}) < length(currDimsLengths))
                    % Replicate along the time dimension
                    outdata = repmat(replace_vars.value{vv},...
                        [ones(ndims(replace_vars.value{vv}),1)',length(currDimsLengths)]);
                elseif isequal(size(replace_vars.value{vv}),currDimsLengths')
                    outdata = replace_vars.value{vv};
                else
                    error('Input data must be a scalar or match the required restart data array size. Check and try again.');
                end
                
                if wasUnlimited < 0
                    % We can just dump the entire data without specifying over
                    % what indices.
                    netcdf.putVar(ncout, varid, outdata);
                else
                    % Use the dimension length we extracted above to output the
                    % data with the valid unlimited dimension format.
                    netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, outdata);
                end
            end
        end
    end

    % If writtenAlready is zero, we haven't had one of the variables we're
    % replacing, so just dump the existing data.
    if writtenAlready == 0
        % Grab the data
        data = netcdf.getVar(nc, varid);
%         disp('Grabbed the data')
        
        if wasUnlimited < 0
            % We can just dump the entire data without specifying over
            % what indices.
            netcdf.putVar(ncout, varid, data);
        else
            % Do we need to crop this variable?
            if isfield(inputConf,'crop') && (size(data,find(tIdx)) ~= timedim)
                d = currDimsLengths';
                
                % Can we do this the easy way?
                if isvector(data)
                    data = data(1:timedim);
                else    % If it's not a vector, do it the hard way
                    % Create a cell array of indices for the new cropped data array
                    ind = {};
                    for k = 1:ndims(data)
                        ind = [ind 1:d(k)];
                    end
                    
                    % Crop it
                    data = data(ind{:});
                end
            end
            
            % Use the dimension length we extracted above to output the
            % data with the valid unlimited dimension format.
            netcdf.putVar(ncout, varid, zeros(length(currDimsLengths), 1), currDimsLengths, data);
        end
    end

    if ftbverbose
        fprintf('done.\n')
    end
end

netcdf.close(nc)
netcdf.close(ncout)

if ftbverbose
    fprintf(['end   : ' subname '\n'])
end

fprintf('All done!\n')
