<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of get_HYCOM_forcing</title>
  <meta name="keywords" content="get_HYCOM_forcing">
  <meta name="description" content="Get mean flow, temperature, salinity, surface elevation and denstiy data">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">fvcom_prepro</a> &gt; get_HYCOM_forcing.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for fvcom_prepro&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>get_HYCOM_forcing
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Get mean flow, temperature, salinity, surface elevation and denstiy data</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function data = get_HYCOM_forcing(Mobj, modelTime, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Get mean flow, temperature, salinity, surface elevation and denstiy data
 from HYCOM model outputs through their OPeNDAP server.

 data = get_HYCOM_forcing(Mobj, modelTime)

 DESCRIPTION:
   Using OPeNDAP, extract the necessary parameters to create an FVCOM
   forcing file.

 INPUT:
   Mobj - MATLAB mesh object with the following fields:
           - have_lonlat - boolean indicating whether lat/long values are
           present in Mobj.
           - lon, lat - longitude and latitudes of the model grid nodes.
   modelTime - Modified Julian Date start and end times
   varlist - [optional] cell array of variables to download. Use HYCOM
       names (e.g. ssh, salinity, temperature, u, v). If omitted,
       downloads salinity, temperature and ssh only.
   three - [optional] boolean. Set to true to download the 3 hourly data
       for the period 1992/10/2 to 2008/09/18 (inclusive). Defaults to
       false and downloads only the daily data.

 OUTPUT:
   data - struct of the data necessary to force FVCOM. These can be
   interpolated onto the unstructured grid in Mobj using grid2fvcom.m.

 The parameters (and the corresponding field names returned) which are
 obtained from the HYCOM data are:
     - time [MT]
     - temperature [temperature]
     - salinity [salinity]
     - u mean flow component [u]
     - v mean flow component [v]
     - daily mean sea surface height [ssh]

 EXAMPLE USAGE:
   To download the default parameters (temperature, salinity and ssh):

       modeltime = [55561, 55591]; % time period in Modified Julian Days
       hycom = get_HYCOM_forcing(Mobj, modeltime);

   To download only sea surface height:

       modeltime = [55561, 55591]; % time period in Modified Julian Days
       hycom = get_HYCOM_forcing(Mobj, modeltime, {'ssh'})

 Author(s)
   Pierre Cazenave (Plymouth Marine Laboratory)

 Revision history:
   2013-01-31 First version.
   2013-08-19 Make some more progress in getting this working. Mainly
   change the way the dates are handled to form the relevant URL for
   downloading the data.
   2013-09-03 More incremetal changes to get the function working. At the
   moment, I'm ignoring the old OPeNDAP toolbox for reading the data from
   the HYCOM OPeNDAP server.
   2013-09-05 It's working! Also add a data.time variable with the time
   stamps from the HYCOM data.
   2013-12-02 Add sea surface height to the list of variables that can be
   downloaded.
   2013-12-09 Add ability to specify particular variables to download.
   2013-12-12 Fix the handling of the variable input list of field names.
   2015-05-21 Add support for the Global Reanalysis data which extends
   coverage back to 1992 (previously limited to 2008 with the Global
   Analysis data). The Global Analysis data is used from 2008 onwards even
   though the reanalysis exists up to 2012.
   2016-01-04 Add support for the three hourly output data for the 19.0
   and 19.1 experiments.
   2016-07-06 Add new data sets from the HYCOM server (post-2014).

==========================================================================</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function url = get_url(time, threehourly)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function data = get_HYCOM_forcing(Mobj, modelTime, varargin)</a>
0002 <span class="comment">% Get mean flow, temperature, salinity, surface elevation and denstiy data</span>
0003 <span class="comment">% from HYCOM model outputs through their OPeNDAP server.</span>
0004 <span class="comment">%</span>
0005 <span class="comment">% data = get_HYCOM_forcing(Mobj, modelTime)</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% DESCRIPTION:</span>
0008 <span class="comment">%   Using OPeNDAP, extract the necessary parameters to create an FVCOM</span>
0009 <span class="comment">%   forcing file.</span>
0010 <span class="comment">%</span>
0011 <span class="comment">% INPUT:</span>
0012 <span class="comment">%   Mobj - MATLAB mesh object with the following fields:</span>
0013 <span class="comment">%           - have_lonlat - boolean indicating whether lat/long values are</span>
0014 <span class="comment">%           present in Mobj.</span>
0015 <span class="comment">%           - lon, lat - longitude and latitudes of the model grid nodes.</span>
0016 <span class="comment">%   modelTime - Modified Julian Date start and end times</span>
0017 <span class="comment">%   varlist - [optional] cell array of variables to download. Use HYCOM</span>
0018 <span class="comment">%       names (e.g. ssh, salinity, temperature, u, v). If omitted,</span>
0019 <span class="comment">%       downloads salinity, temperature and ssh only.</span>
0020 <span class="comment">%   three - [optional] boolean. Set to true to download the 3 hourly data</span>
0021 <span class="comment">%       for the period 1992/10/2 to 2008/09/18 (inclusive). Defaults to</span>
0022 <span class="comment">%       false and downloads only the daily data.</span>
0023 <span class="comment">%</span>
0024 <span class="comment">% OUTPUT:</span>
0025 <span class="comment">%   data - struct of the data necessary to force FVCOM. These can be</span>
0026 <span class="comment">%   interpolated onto the unstructured grid in Mobj using grid2fvcom.m.</span>
0027 <span class="comment">%</span>
0028 <span class="comment">% The parameters (and the corresponding field names returned) which are</span>
0029 <span class="comment">% obtained from the HYCOM data are:</span>
0030 <span class="comment">%     - time [MT]</span>
0031 <span class="comment">%     - temperature [temperature]</span>
0032 <span class="comment">%     - salinity [salinity]</span>
0033 <span class="comment">%     - u mean flow component [u]</span>
0034 <span class="comment">%     - v mean flow component [v]</span>
0035 <span class="comment">%     - daily mean sea surface height [ssh]</span>
0036 <span class="comment">%</span>
0037 <span class="comment">% EXAMPLE USAGE:</span>
0038 <span class="comment">%   To download the default parameters (temperature, salinity and ssh):</span>
0039 <span class="comment">%</span>
0040 <span class="comment">%       modeltime = [55561, 55591]; % time period in Modified Julian Days</span>
0041 <span class="comment">%       hycom = get_HYCOM_forcing(Mobj, modeltime);</span>
0042 <span class="comment">%</span>
0043 <span class="comment">%   To download only sea surface height:</span>
0044 <span class="comment">%</span>
0045 <span class="comment">%       modeltime = [55561, 55591]; % time period in Modified Julian Days</span>
0046 <span class="comment">%       hycom = get_HYCOM_forcing(Mobj, modeltime, {'ssh'})</span>
0047 <span class="comment">%</span>
0048 <span class="comment">% Author(s)</span>
0049 <span class="comment">%   Pierre Cazenave (Plymouth Marine Laboratory)</span>
0050 <span class="comment">%</span>
0051 <span class="comment">% Revision history:</span>
0052 <span class="comment">%   2013-01-31 First version.</span>
0053 <span class="comment">%   2013-08-19 Make some more progress in getting this working. Mainly</span>
0054 <span class="comment">%   change the way the dates are handled to form the relevant URL for</span>
0055 <span class="comment">%   downloading the data.</span>
0056 <span class="comment">%   2013-09-03 More incremetal changes to get the function working. At the</span>
0057 <span class="comment">%   moment, I'm ignoring the old OPeNDAP toolbox for reading the data from</span>
0058 <span class="comment">%   the HYCOM OPeNDAP server.</span>
0059 <span class="comment">%   2013-09-05 It's working! Also add a data.time variable with the time</span>
0060 <span class="comment">%   stamps from the HYCOM data.</span>
0061 <span class="comment">%   2013-12-02 Add sea surface height to the list of variables that can be</span>
0062 <span class="comment">%   downloaded.</span>
0063 <span class="comment">%   2013-12-09 Add ability to specify particular variables to download.</span>
0064 <span class="comment">%   2013-12-12 Fix the handling of the variable input list of field names.</span>
0065 <span class="comment">%   2015-05-21 Add support for the Global Reanalysis data which extends</span>
0066 <span class="comment">%   coverage back to 1992 (previously limited to 2008 with the Global</span>
0067 <span class="comment">%   Analysis data). The Global Analysis data is used from 2008 onwards even</span>
0068 <span class="comment">%   though the reanalysis exists up to 2012.</span>
0069 <span class="comment">%   2016-01-04 Add support for the three hourly output data for the 19.0</span>
0070 <span class="comment">%   and 19.1 experiments.</span>
0071 <span class="comment">%   2016-07-06 Add new data sets from the HYCOM server (post-2014).</span>
0072 <span class="comment">%</span>
0073 <span class="comment">%==========================================================================</span>
0074 
0075 subname = <span class="string">'get_HYCOM_forcing'</span>;
0076 
0077 <span class="keyword">global</span> ftbverbose;
0078 <span class="keyword">if</span> ftbverbose
0079     fprintf(<span class="string">'\nbegin : %s\n'</span>, subname)
0080 <span class="keyword">end</span>
0081 
0082 <span class="comment">% For checking whether to use the third-party OPeNDAP toolbox or native</span>
0083 <span class="comment">% MATLAB tools. OPeNDAP support is included in MATLAB version 7.14 onwards.</span>
0084 <span class="comment">% Although this check is made, I haven't actually written the code for the</span>
0085 <span class="comment">% third-party toolbox. If you need it, I be pleased if you wrote an</span>
0086 <span class="comment">% equivalent to the native version.</span>
0087 v714date = datenum(2012, 3, 1);
0088 currdate = ver(<span class="string">'MATLAB'</span>);
0089 currdate = datenum(currdate.Date);
0090 
0091 <span class="keyword">if</span> datenum(currdate) &lt; v714date
0092     error([<span class="string">'This version of MATLAB does not have native OPeNDAP '</span>, <span class="keyword">...</span>
0093         <span class="string">'support and this function relies on that support. If you '</span>, <span class="keyword">...</span>
0094         <span class="string">'require this function, you will have to add the '</span>, <span class="keyword">...</span>
0095         <span class="string">'functionality with the third-party OPeNDAP toolbox.'</span>])
0096 <span class="keyword">end</span>
0097 
0098 <span class="comment">% Check if we've been given a cell array of variables and set the varlist</span>
0099 <span class="comment">% to that, otherwise default to temperature, salinity and sea surface</span>
0100 <span class="comment">% height. For the three option, assume we want daily data unless three is</span>
0101 <span class="comment">% true, in which case set the threehourly parameter to be the string</span>
0102 <span class="comment">% required for the THREDDS URL (/3hrly), otherwise default to daily data.</span>
0103 threehourly = <span class="string">''</span>;
0104 <span class="keyword">if</span> nargin == 2 || nargin &gt; 3
0105     varlist = {<span class="string">'temperature'</span>, <span class="string">'salinity'</span>, <span class="string">'ssh'</span>};
0106 <span class="keyword">end</span>
0107 <span class="keyword">if</span> nargin &gt; 2
0108     <span class="comment">% To maintain backwards compatibility, assume if we've been given a</span>
0109     <span class="comment">% cell array as the third option, that's the variables to download.</span>
0110     <span class="comment">% Otherwise, iterate through the argument as key-parameter pairs.</span>
0111     <span class="keyword">if</span> nargin == 3
0112         <span class="keyword">if</span> iscell(varargin{1})
0113             varlist = varargin{1};
0114             assert(iscell(varargin{1}), [<span class="keyword">...</span>
0115                 <span class="string">'List of variables to extract must'</span>, <span class="keyword">...</span>
0116                 <span class="string">' be a cell array: {''var1'', ''var2''}'</span>])
0117         <span class="keyword">end</span>
0118     <span class="keyword">else</span>
0119         <span class="keyword">for</span> v = 1:2:length(varargin)
0120             <span class="keyword">switch</span> varargin{v}
0121                 <span class="keyword">case</span> <span class="string">'three'</span>
0122                     <span class="keyword">if</span> varargin{v + 1}
0123                         threehourly = <span class="string">'/3hrly'</span>;
0124                     <span class="keyword">end</span>
0125                     <span class="keyword">if</span> modelTime(1) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0126                         error([<span class="string">'The three hourly output is not '</span>, <span class="keyword">...</span>
0127                                 <span class="string">'configured for the period beyond '</span>, <span class="keyword">...</span>
0128                                 <span class="string">'2008/09/18 in this function. Please '</span>, <span class="keyword">...</span>
0129                                 <span class="string">'disable three hourly downloads, or '</span>, <span class="keyword">...</span>
0130                                 <span class="string">'edit this function to suit your needs.'</span>])
0131                     <span class="keyword">end</span>
0132             <span class="keyword">end</span>
0133         <span class="keyword">end</span>
0134     <span class="keyword">end</span>
0135 <span class="keyword">end</span>
0136 
0137 <span class="comment">% Get the extent of the model domain (in spherical).</span>
0138 <span class="keyword">if</span> ~Mobj.have_lonlat
0139     error(<span class="string">'Need spherical coordinates to extract the forcing data'</span>)
0140 <span class="keyword">else</span>
0141     <span class="comment">% Add a buffer of two grid cells in latitude and two in longitude to</span>
0142     <span class="comment">% make sure the model domain is fully covered by the extracted data.</span>
0143     [dx, dy] = deal(1/12, 1/12); <span class="comment">% HYCOM resolution in degrees</span>
0144     <span class="comment">% West, east, south, north</span>
0145     extents = [min(Mobj.lon(:)) - (2 * dx), max(Mobj.lon(:)) + (2 * dx), <span class="keyword">...</span>
0146         min(Mobj.lat(:)) - (2 * dy), max(Mobj.lat(:)) + (2 * dy)];
0147 <span class="keyword">end</span>
0148 
0149 <span class="comment">% List of URL suffixes so we can dynamically build the URL for each time</span>
0150 <span class="comment">% step.</span>
0151 suffix.MT           = {<span class="string">'time'</span>, <span class="string">'MT'</span>};
0152 suffix.Longitude    = {<span class="string">'lon'</span>, <span class="string">'Longitude'</span>};
0153 suffix.Latitude     = {<span class="string">'lat'</span>, <span class="string">'Latitude'</span>};
0154 suffix.Depth        = {<span class="string">'depth'</span>, <span class="string">'Depth'</span>};
0155 suffix.temperature  = {<span class="string">'water_temp'</span>, <span class="string">'temperature'</span>};
0156 suffix.salinity     = {<span class="string">'salinity'</span>, <span class="string">'salinity'</span>};
0157 suffix.u            = {<span class="string">'water_u'</span>, <span class="string">'u'</span>};
0158 suffix.v            = {<span class="string">'water_v'</span>, <span class="string">'v'</span>};
0159 suffix.ssh          = {<span class="string">'surf_el'</span>, <span class="string">'ssh'</span>};
0160 
0161 <span class="comment">% Get the URL to use for the first time step.</span>
0162 url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(modelTime(1), threehourly);
0163 
0164 <span class="keyword">if</span> modelTime(1) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0165     name_index = 1;
0166 <span class="keyword">elseif</span> modelTime(1) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0167     name_index = 2;
0168 <span class="keyword">end</span>
0169 hycom.MT            = [url, suffix.MT{name_index}];          <span class="comment">% time [1D]</span>
0170 hycom.Longitude     = [url, suffix.Longitude{name_index}];   <span class="comment">% [2D]</span>
0171 hycom.Latitude      = [url, suffix.Latitude{name_index}];    <span class="comment">% [2D]</span>
0172 hycom.Depth         = [url, suffix.Depth{name_index}];       <span class="comment">% water depth [2D]</span>
0173 hycom.temperature   = [url, suffix.temperature{name_index}]; <span class="comment">% [4D]</span>
0174 hycom.salinity      = [url, suffix.salinity{name_index}];    <span class="comment">% [4D]</span>
0175 hycom.ssh           = [url, suffix.ssh{name_index}];         <span class="comment">% sea surface height [3D]</span>
0176 hycom.u             = [url, suffix.u{name_index}];           <span class="comment">% mean flow [4D]</span>
0177 hycom.v             = [url, suffix.v{name_index}];           <span class="comment">% mean flow [4D]</span>
0178 
0179 <span class="comment">% Load the depth data (1D vector).</span>
0180 ncid = netcdf.open(hycom.Depth, <span class="string">'NOWRITE'</span>);
0181 <span class="keyword">try</span>
0182     varid = netcdf.inqVarID(ncid, <span class="string">'Depth'</span>);
0183 <span class="keyword">catch</span>
0184     varid = netcdf.inqVarID(ncid, <span class="string">'depth'</span>);
0185 <span class="keyword">end</span>
0186 
0187 <span class="comment">% HYCOM has fixed depths, so the array which returned here is just</span>
0188 <span class="comment">% a list of those depths. We need them to interpolate the vertical</span>
0189 <span class="comment">% structure onto the FVCOM sigma levels.</span>
0190 data.Depth.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0191 
0192 netcdf.close(ncid)
0193 
0194 <span class="comment">% Get the number of vertical levels.</span>
0195 nz = length(data.Depth.data);
0196 
0197 <span class="comment">% Set a time increment is we've got the three-hourly flag passed to the</span>
0198 <span class="comment">% function. At some point, this may have to be a string comparison such</span>
0199 <span class="comment">% that we can use different outputs (if the HYCOM folks add them), but for</span>
0200 <span class="comment">% now, we just assume non-empty strings means three-hourly data. This will</span>
0201 <span class="comment">% also break horribly if we request data from both daily and three-hourly</span>
0202 <span class="comment">% data sets.</span>
0203 <span class="keyword">if</span> ~isempty(threehourly)
0204     time_increment = 3/24;
0205 <span class="keyword">else</span>
0206     time_increment = 1;
0207 <span class="keyword">end</span>
0208 times = modelTime(1):time_increment:modelTime(2);
0209 nt = length(times);
0210 
0211 <span class="comment">% Before we go off downloading data, check the variables we've been asked</span>
0212 <span class="comment">% for are actually valid HYCOM names.</span>
0213 <span class="keyword">for</span> vv = 1:length(varlist)
0214     <span class="keyword">if</span> iscell(varlist) &amp;&amp; ~isfield(hycom, varlist{vv})
0215         error(<span class="string">'Variable %s is not a valid HYCOM variable name.'</span>, varlist{vv})
0216     <span class="keyword">end</span>
0217 <span class="keyword">end</span>
0218 
0219 <span class="comment">% Initialise the value of url so we can compare it each loop and only</span>
0220 <span class="comment">% reopen the connection to the server if we've crossed into a different</span>
0221 <span class="comment">% data set.</span>
0222 url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(modelTime(1), threehourly);
0223 
0224 data.time = [];
0225 c = 1; <span class="comment">% counter for the tmjd cell array.</span>
0226 <span class="keyword">for</span> tt = 1:nt
0227 
0228     <span class="comment">% So we can use either the Reanalysis (pre-2008) or Analysis</span>
0229     <span class="comment">% (post-2008) data, we need to build the request struct based on the</span>
0230     <span class="comment">% current time.</span>
0231 
0232     <span class="comment">% Set up a struct of the HYCOM data sets in which we're interested.</span>
0233     <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0234         name_index = 1;
0235     <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0236         name_index = 2;
0237     <span class="keyword">end</span>
0238     hycom.MT            = [url, suffix.MT{name_index}];          <span class="comment">% time [1D]</span>
0239     hycom.Longitude     = [url, suffix.Longitude{name_index}];   <span class="comment">% [2D]</span>
0240     hycom.Latitude      = [url, suffix.Latitude{name_index}];    <span class="comment">% [2D]</span>
0241     hycom.Depth         = [url, suffix.Depth{name_index}];       <span class="comment">% water depth [2D]</span>
0242     hycom.temperature   = [url, suffix.temperature{name_index}]; <span class="comment">% [4D]</span>
0243     hycom.salinity      = [url, suffix.salinity{name_index}];    <span class="comment">% [4D]</span>
0244     hycom.ssh           = [url, suffix.ssh{name_index}];         <span class="comment">% sea surface height [3D]</span>
0245     hycom.u             = [url, suffix.u{name_index}];           <span class="comment">% mean flow [4D]</span>
0246     hycom.v             = [url, suffix.v{name_index}];           <span class="comment">% mean flow [4D]</span>
0247 
0248     oldurl = url;
0249     url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(times(tt), threehourly);
0250     <span class="comment">% Only reopen the connection if the two URLs differ.</span>
0251     <span class="keyword">if</span> ~strcmpi(oldurl, url) || tt == 1
0252         <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0253             hycom.MT = [url, suffix.MT{1}];
0254         <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0255             hycom.MT = [url, suffix.MT{2}];
0256         <span class="keyword">end</span>
0257         ncid = netcdf.open(hycom.MT, <span class="string">'NOWRITE'</span>);
0258         <span class="keyword">try</span>
0259             varid = netcdf.inqVarID(ncid, <span class="string">'MT'</span>);
0260         <span class="keyword">catch</span>
0261             varid = netcdf.inqVarID(ncid, <span class="string">'time'</span>);
0262         <span class="keyword">end</span>
0263 
0264         <span class="comment">% Add the new data to the cell array. This should build up an</span>
0265         <span class="comment">% array of unique time series. We can then use these to query</span>
0266         <span class="comment">% for the time indices for each time step later.</span>
0267         data.MT.data{c} = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0268 
0269         netcdf.close(ncid)
0270 
0271         <span class="comment">% Convert to Gregorian date and then to Modified Julian Days. The</span>
0272         <span class="comment">% Global Reanalysis stores time as hours since 2000-01-01, the</span>
0273         <span class="comment">% Global Analysis as days since 1900-12-31.</span>
0274         <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0275             t{c} = datevec((data.MT.data{c} / 24) + datenum(2000, 1, 1, 0, 0, 0));
0276         <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0277             t{c} = datevec(data.MT.data{c} + datenum(1900, 12, 31, 0, 0, 0));
0278         <span class="keyword">end</span>
0279         tmjd{c} = greg2mjulian(t{c}(:,1), t{c}(:,2), t{c}(:,3), t{c}(:,4), t{c}(:,5), t{c}(:,6));
0280 
0281         c = c + 1;
0282     <span class="keyword">end</span>
0283 <span class="keyword">end</span>
0284 
0285 <span class="comment">% Open the relevant spatial variables on the remote server and download the</span>
0286 <span class="comment">% spatial data required to subset the HYCOM data.</span>
0287 ncid = netcdf.open(hycom.Longitude, <span class="string">'NOWRITE'</span>);
0288 <span class="keyword">try</span>
0289     varid = netcdf.inqVarID(ncid, suffix.Longitude{1});
0290 <span class="keyword">catch</span>
0291     varid = netcdf.inqVarID(ncid, suffix.Longitude{2});
0292 <span class="keyword">end</span>
0293 
0294 data.X.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0295 
0296 netcdf.close(ncid)
0297 
0298 <span class="comment">% Make the longitude values in the range -180 to 180 (to match the</span>
0299 <span class="comment">% model inputs).</span>
0300 data.X.data = mod(data.X.data, 360);
0301 data.X.data(data.X.data &gt; 180) = data.X.data(data.X.data &gt; 180) - 360;
0302 
0303 ncid = netcdf.open(hycom.Latitude, <span class="string">'NOWRITE'</span>);
0304 <span class="keyword">try</span>
0305     varid = netcdf.inqVarID(ncid, suffix.Latitude{1});
0306 <span class="keyword">catch</span>
0307     varid = netcdf.inqVarID(ncid, suffix.Latitude{2});
0308 <span class="keyword">end</span>
0309 
0310 data.Y.data = netcdf.getVar(ncid, varid, <span class="string">'double'</span>);
0311 
0312 netcdf.close(ncid)
0313 
0314 <span class="comment">% If the spatial data are vectors, turn them in to matrices here.</span>
0315 <span class="keyword">if</span> isvector(data.X.data) &amp;&amp; isvector(data.Y.data)
0316     [data.X.data, data.Y.data] = meshgrid(data.X.data, data.Y.data);
0317     <span class="comment">% Orient the arrays as required for the calls to the remote server.</span>
0318     data.X.data = data.X.data';
0319     data.Y.data = data.Y.data';
0320 <span class="keyword">end</span>
0321 
0322 <span class="comment">% Create indices of the size of the arrays.</span>
0323 data.X.idx = repmat(1:size(data.X.data, 1), [size(data.X.data, 2), 1])';
0324 data.Y.idx = repmat(1:size(data.Y.data, 2), [size(data.Y.data, 1), 1]);
0325 <span class="comment">%data.Y.idx = 1:size(data.Y.data, 2) - 1;</span>
0326 
0327 <span class="comment">% Find the indices which cover the model domain then find the extremes to</span>
0328 <span class="comment">% request only a subset from the OPeNDAP server.</span>
0329 idx = data.X.data &gt; extents(1) &amp; data.X.data &lt; extents(2) &amp; data.Y.data &gt; extents(3) &amp; data.Y.data &lt; extents(4);
0330 xrange = [min(data.X.idx(idx)), max(data.X.idx(idx))];
0331 yrange = [min(data.Y.idx(idx)), max(data.Y.idx(idx))];
0332 
0333 data.lon = data.X.data(xrange(1):xrange(2), yrange(1):yrange(2));
0334 data.lat = data.Y.data(xrange(1):xrange(2), yrange(1):yrange(2));
0335 
0336 <span class="comment">% Clear out the full lon/lat arrays.</span>
0337 <span class="comment">% data = rmfield(data, {'X', 'Y'});</span>
0338 
0339 <span class="comment">% Now get the variables for which we've been asked.</span>
0340 fields = varlist;
0341 
0342 <span class="keyword">for</span> aa = 1:length(fields)
0343     <span class="comment">% Store the downloaded data in a struct. Assume the spatial</span>
0344     <span class="comment">% data is identical to that in data.lon and data.lat.</span>
0345     data.(fields{aa}).data = [];
0346 
0347     ncid = netcdf.open(hycom.(fields{aa}));
0348     varid = netcdf.inqVarID(ncid, suffix.(fields{aa}){name_index});
0349 
0350     <span class="comment">% If you don't know what it contains, start by using the</span>
0351     <span class="comment">% 'netcdf.inq' and ncinfo operations:</span>
0352     <span class="comment">%[numdims, numvars, numglobalatts, unlimdimid] = netcdf.inq(ncid);</span>
0353     <span class="comment">%ncid_info = ncinfo(hycom.(fields{aa}));</span>
0354 
0355     <span class="comment">% Typically these data are 4D, with dimensions of:</span>
0356     <span class="comment">%   - x (X)</span>
0357     <span class="comment">%   - y (Y)</span>
0358     <span class="comment">%   - depth (Depth)</span>
0359     <span class="comment">%   - time (MT)</span>
0360     <span class="comment">% except in the case of sea surface height, where we lose</span>
0361     <span class="comment">% the depth dimension. For all other variables, we want all</span>
0362     <span class="comment">% depths but only a subset in time and space.</span>
0363 
0364     <span class="comment">% Since the HYCOM OPeNDAP server is so spectacularly slow,</span>
0365     <span class="comment">% extract a day's data at a time and stick them together</span>
0366     <span class="comment">% here. If nothing else, this at least means I can give</span>
0367     <span class="comment">% some indication of progress, rather than just wait for</span>
0368     <span class="comment">% something to eventually happen.</span>
0369     nx = (xrange(2) - xrange(1)) + 1;
0370     ny = (yrange(2) - yrange(1)) + 1;
0371 
0372     <span class="comment">% Preallocate the output so we don't append to an array</span>
0373     <span class="comment">% (which is slow). Sea surface height is 3D only (all the</span>
0374     <span class="comment">% other variables are 4D). So, it needs its own little</span>
0375     <span class="comment">% check all to itself.</span>
0376     <span class="keyword">if</span> strcmpi(fields{aa}, <span class="string">'ssh'</span>) == 1
0377         was_zeta = true; <span class="comment">% set boolean for surface elevation</span>
0378         data.(fields{aa}).data = nan(nx, ny, nt);
0379     <span class="keyword">else</span>
0380         was_zeta = false;
0381         data.(fields{aa}).data = nan(nx, ny, nz, nt);
0382     <span class="keyword">end</span>
0383 
0384     c = 0; <span class="comment">% counter for iterating through tmjd.</span>
0385 
0386     <span class="keyword">for</span> tt = 1:nt
0387         <span class="keyword">if</span> ftbverbose
0388             fprintf(<span class="string">'%s: time %i of %i... '</span>, fields{aa}, tt, nt)
0389         <span class="keyword">end</span>
0390 
0391         <span class="comment">% Get the current url value for this time step. This</span>
0392         <span class="comment">% approach means we can grab data which straddles a</span>
0393         <span class="comment">% boundary between HYCOM outputs. Only reopen the</span>
0394         <span class="comment">% connection if the url value has changed. At this</span>
0395         <span class="comment">% point we also need to get ourselves a new time index</span>
0396         <span class="comment">% using modelTime and the cell array tmjd.</span>
0397         oldurl = url;
0398         url = <a href="#_sub1" class="code" title="subfunction url = get_url(time, threehourly)">get_url</a>(times(tt), threehourly);
0399 
0400         <span class="keyword">if</span> ~strcmpi(oldurl, url) || tt == 1
0401             <span class="keyword">if</span> times(tt) &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0402                 hycom.(fields{aa}) = [url, suffix.(fields{aa}){1}];
0403             <span class="keyword">elseif</span> times(tt) &gt;= greg2mjulian(2008, 09, 19, 0, 0, 0)
0404                 hycom.(fields{aa}) = [url, suffix.(fields{aa}){2}];
0405             <span class="keyword">end</span>
0406             <span class="comment">% Close any existing open connections and reopen with</span>
0407             <span class="comment">% the new URL.</span>
0408             netcdf.close(ncid)
0409             ncid = netcdf.open(hycom.(fields{aa}));
0410             <span class="keyword">try</span>
0411                 varid = netcdf.inqVarID(ncid, suffix.(fields{aa}){1});
0412             <span class="keyword">catch</span>
0413                 varid = netcdf.inqVarID(ncid, suffix.(fields{aa}){2});
0414             <span class="keyword">end</span>
0415 
0416             c = c + 1;
0417         <span class="keyword">end</span>
0418 
0419         <span class="comment">% Find the time index closest to the current model</span>
0420         <span class="comment">% time.</span>
0421         [~, ts] = min(abs(tmjd{c} - times(tt)));
0422 
0423         <span class="keyword">if</span> was_zeta
0424             <span class="comment">% netCDF starts at zero, hence -1.</span>
0425             start = [xrange(1), yrange(1), ts] - 1;
0426             count = [nx, ny, 1];
0427             data.(fields{aa}).data(:, :, tt) = netcdf.getVar(ncid, varid, start, count, <span class="string">'double'</span>);
0428         <span class="keyword">else</span>
0429             <span class="comment">% netCDF starts at zero, hence -1.</span>
0430             start = [xrange(1), yrange(1), 1, ts] - 1;
0431             count = [nx, ny, nz, 1];
0432             data.(fields{aa}).data(:, :, :, tt) = netcdf.getVar(ncid, varid, start, count, <span class="string">'double'</span>);
0433         <span class="keyword">end</span>
0434 
0435         <span class="comment">% Build an array of the HYCOM times. Only do so once so</span>
0436         <span class="comment">% we don't end up appending it multiple times.</span>
0437         <span class="keyword">if</span> length(data.time) &lt; nt
0438             data.time = [data.time; tmjd{c}(ts)];
0439         <span class="keyword">end</span>
0440 
0441         <span class="keyword">if</span> ftbverbose; fprintf(<span class="string">'done.\n'</span>); <span class="keyword">end</span>
0442     <span class="keyword">end</span>
0443     netcdf.close(ncid);
0444 <span class="keyword">end</span>
0445 
0446 <span class="keyword">if</span> ftbverbose
0447     fprintf(<span class="string">'end   : %s\n'</span>, subname)
0448 <span class="keyword">end</span>
0449 
0450 <a name="_sub1" href="#_subfunctions" class="code">function url = get_url(time, threehourly)</a>
0451 <span class="comment">% Child function to find the relevant URL to use for a given time step.</span>
0452 <span class="comment">%</span>
0453 <span class="comment">% url = get_url(time, threehourly);</span>
0454 <span class="comment">%</span>
0455 <span class="comment">% INPUT:</span>
0456 <span class="comment">%   time - Modified Julian Day</span>
0457 <span class="comment">%   threehourly - additional string to append for optional three hourly</span>
0458 <span class="comment">%   outputs for the 1992/10/02 to 2008/09/18 period. Leave empty for daily</span>
0459 <span class="comment">%   data.</span>
0460 <span class="comment">%</span>
0461 <span class="comment">% OUTPUT:</span>
0462 <span class="comment">%   url - string of the approprate URL for the date supplied in time.</span>
0463 <span class="comment">%</span>
0464 
0465 [t1, t2, t3, t4, t5, t6] = datevec(datestr(now));
0466 
0467 <span class="keyword">if</span> time &lt; greg2mjulian(1992, 10, 2, 0, 0, 0)
0468     error(<span class="string">'No HYCOM data available prior to 1992-10-02. Select a start date from 1992-10-02 onwards.'</span>)
0469 <span class="keyword">elseif</span> time &gt;= greg2mjulian(1992, 10, 2, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(1995, 7, 31, 0, 0, 0)
0470     warning(<span class="string">'Using the HYCOM Global Reanalysis data for dates up to 2008/09/16, thereafter the Global Analysis.'</span>)
0471     url = sprintf(<span class="string">'http://tds.hycom.org/thredds/dodsC/GLBu0.08/expt_19.0%s?'</span>, threehourly);
0472 <span class="keyword">elseif</span> time &gt;= greg2mjulian(1995, 7, 31, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2008, 09, 19, 0, 0, 0)
0473     warning(<span class="string">'Using the HYCOM Global Reanalysis data for dates up to 2008/09/16, thereafter the Global Analysis.'</span>)
0474     url = sprintf(<span class="string">'http://tds.hycom.org/thredds/dodsC/GLBu0.08/expt_19.1%s?'</span>, threehourly);
0475 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2008, 9, 19, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2009, 5, 7, 0, 0, 0)
0476     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.6?'</span>;
0477 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2009, 5, 7, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2011, 1, 3, 0, 0, 0)
0478     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.8?'</span>;
0479 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2011, 1, 3, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2013, 8, 21, 0, 0, 0)
0480     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_90.9?'</span>;
0481 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2013, 8, 21, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2014, 4, 21, 0, 0, 0):
0482     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.0?'</span>;
0483 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2014, 4, 21, 0, 0, 0) &amp;&amp; time &lt; greg2mjulian(2016, 4, 18, 0, 0, 0):
0484     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.1?'</span>;
0485 <span class="keyword">elseif</span> time &gt;= greg2mjulian(2016, 4, 18, 0, 0, 0) &amp;&amp; time &lt;= greg2mjulian(t1, t2, t3, t4, t5, t6):
0486     url = <span class="string">'http://tds.hycom.org/thredds/dodsC/GLBa0.08/expt_91.2?'</span>;
0487 <span class="keyword">elseif</span> time &gt; greg2mjulian(t1, t2, t3, t4, t5, t6)
0488     error(<span class="string">'Given date is in the future.'</span>)
0489 <span class="keyword">else</span>
0490     error(<span class="string">'Date is outside of the known spacetime continuum. See help TARDIS.'</span>)
0491 <span class="keyword">end</span>
0492</pre></div>
<hr><address>Generated on Wed 10-Aug-2016 16:44:39 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>