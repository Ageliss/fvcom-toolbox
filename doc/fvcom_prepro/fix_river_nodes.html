<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fix_river_nodes</title>
  <meta name="keywords" content="fix_river_nodes">
  <meta name="description" content="Takes the automatically identified river node positions generated by">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">fvcom_prepro</a> &gt; fix_river_nodes.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for fvcom_prepro&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>fix_river_nodes
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Takes the automatically identified river node positions generated by</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function Mobj = fix_river_nodes(Mobj, max_discharge, dist_thresh) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Takes the automatically identified river node positions generated by
 get_EHYPE_rivers or get_FVCOM_rivers and splits or removes them based on
 thresholds of discharge for the former and distance from the open
 boundary join with the coastline.

 Mobj = fix_river_nodes(Mobj)

 DESCRIPTION:
   The automatic identifcation of model nodes at which river inputs are
   discharged sometimes leads to problems with model stability.
   Specifically:
       1. Nodes very close to the open boundary join with the coastline
       can also cause high velocities to occur which if you have bounds
       checking enabled, will stop the model.
       2. Very large discharges into relatively small elements (e.g. the
       Rhine discharge) cause the model to crash.

   This function checks that:
       1. Rivers are deleted if their distance from the open boundary join
       with the coastline is less than the specified threshold.
       2. Any rivers with discharges above the specified threshold are
       split over a number of nodes such that each node has a maximum
       discharge less than the treshold.
   This order is relatively important otherwise the splitting could put
   nodes within the land/open boundary joint radius and reduce the river
   discharge for a given river by eliminating only some of the river
   nodes.

 INPUT:
   Mobj - struct generated by get_EHYPE_rivers or get_FVCOM_rivers with
   the following fields:
       nVerts - number of nodes in the model domain
       nObs - number of open boundaries
       lon, lat - nodal positions in spherical coordinates
       tri - unstructured grid triangulation table
       read_obc_nodes - open boundary node IDs
       nRivers - number of rivers in the model domain
       river_nodes - currently identified river nodes
       river_names - currently identified river names
       river_flux - river discharge time series
   max_discharge - river discharge threshold above which rivers will be
       split over several nodes (in m^{3}s^{-1}).
   dist_thresh - distance from the open boundary nodes which connect with
       land within which nodes will be removed from the river data arrays.

 OUTPUT:
   Mobj - struct with adjusted river_* fields listed above.

 TODO:
   - Check we don't split a river node into nodes which fall within the
   distance threshold for the land/open boundary joint.

 Author(s)
   Pierre Cazenave (Plymouth Marine Laboratory)

 Revision history:
   2013-12-13 First version based on the EHYPE section of my
   create_files_monthly.m script.
   2014-01-30 Fix a bug revealed when running this script on a larger
   model domain whereby the splitting of discharges across multiple
   nodes when a threshold discharge is exceeded didn't work if more than
   one river exceeded that threshold. Also add better exclusion of
   candidate river nodes (those with two land boundaries only are now
   excluded, as well as open ocean nodes and existing river nodes).
   2015-09-24 Add check for whether we actually have any rivers to
   process.

==========================================================================</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->



<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Mobj = fix_river_nodes(Mobj, max_discharge, dist_thresh)</a>
0002 <span class="comment">% Takes the automatically identified river node positions generated by</span>
0003 <span class="comment">% get_EHYPE_rivers or get_FVCOM_rivers and splits or removes them based on</span>
0004 <span class="comment">% thresholds of discharge for the former and distance from the open</span>
0005 <span class="comment">% boundary join with the coastline.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Mobj = fix_river_nodes(Mobj)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% DESCRIPTION:</span>
0010 <span class="comment">%   The automatic identifcation of model nodes at which river inputs are</span>
0011 <span class="comment">%   discharged sometimes leads to problems with model stability.</span>
0012 <span class="comment">%   Specifically:</span>
0013 <span class="comment">%       1. Nodes very close to the open boundary join with the coastline</span>
0014 <span class="comment">%       can also cause high velocities to occur which if you have bounds</span>
0015 <span class="comment">%       checking enabled, will stop the model.</span>
0016 <span class="comment">%       2. Very large discharges into relatively small elements (e.g. the</span>
0017 <span class="comment">%       Rhine discharge) cause the model to crash.</span>
0018 <span class="comment">%</span>
0019 <span class="comment">%   This function checks that:</span>
0020 <span class="comment">%       1. Rivers are deleted if their distance from the open boundary join</span>
0021 <span class="comment">%       with the coastline is less than the specified threshold.</span>
0022 <span class="comment">%       2. Any rivers with discharges above the specified threshold are</span>
0023 <span class="comment">%       split over a number of nodes such that each node has a maximum</span>
0024 <span class="comment">%       discharge less than the treshold.</span>
0025 <span class="comment">%   This order is relatively important otherwise the splitting could put</span>
0026 <span class="comment">%   nodes within the land/open boundary joint radius and reduce the river</span>
0027 <span class="comment">%   discharge for a given river by eliminating only some of the river</span>
0028 <span class="comment">%   nodes.</span>
0029 <span class="comment">%</span>
0030 <span class="comment">% INPUT:</span>
0031 <span class="comment">%   Mobj - struct generated by get_EHYPE_rivers or get_FVCOM_rivers with</span>
0032 <span class="comment">%   the following fields:</span>
0033 <span class="comment">%       nVerts - number of nodes in the model domain</span>
0034 <span class="comment">%       nObs - number of open boundaries</span>
0035 <span class="comment">%       lon, lat - nodal positions in spherical coordinates</span>
0036 <span class="comment">%       tri - unstructured grid triangulation table</span>
0037 <span class="comment">%       read_obc_nodes - open boundary node IDs</span>
0038 <span class="comment">%       nRivers - number of rivers in the model domain</span>
0039 <span class="comment">%       river_nodes - currently identified river nodes</span>
0040 <span class="comment">%       river_names - currently identified river names</span>
0041 <span class="comment">%       river_flux - river discharge time series</span>
0042 <span class="comment">%   max_discharge - river discharge threshold above which rivers will be</span>
0043 <span class="comment">%       split over several nodes (in m^{3}s^{-1}).</span>
0044 <span class="comment">%   dist_thresh - distance from the open boundary nodes which connect with</span>
0045 <span class="comment">%       land within which nodes will be removed from the river data arrays.</span>
0046 <span class="comment">%</span>
0047 <span class="comment">% OUTPUT:</span>
0048 <span class="comment">%   Mobj - struct with adjusted river_* fields listed above.</span>
0049 <span class="comment">%</span>
0050 <span class="comment">% TODO:</span>
0051 <span class="comment">%   - Check we don't split a river node into nodes which fall within the</span>
0052 <span class="comment">%   distance threshold for the land/open boundary joint.</span>
0053 <span class="comment">%</span>
0054 <span class="comment">% Author(s)</span>
0055 <span class="comment">%   Pierre Cazenave (Plymouth Marine Laboratory)</span>
0056 <span class="comment">%</span>
0057 <span class="comment">% Revision history:</span>
0058 <span class="comment">%   2013-12-13 First version based on the EHYPE section of my</span>
0059 <span class="comment">%   create_files_monthly.m script.</span>
0060 <span class="comment">%   2014-01-30 Fix a bug revealed when running this script on a larger</span>
0061 <span class="comment">%   model domain whereby the splitting of discharges across multiple</span>
0062 <span class="comment">%   nodes when a threshold discharge is exceeded didn't work if more than</span>
0063 <span class="comment">%   one river exceeded that threshold. Also add better exclusion of</span>
0064 <span class="comment">%   candidate river nodes (those with two land boundaries only are now</span>
0065 <span class="comment">%   excluded, as well as open ocean nodes and existing river nodes).</span>
0066 <span class="comment">%   2015-09-24 Add check for whether we actually have any rivers to</span>
0067 <span class="comment">%   process.</span>
0068 <span class="comment">%</span>
0069 <span class="comment">%==========================================================================</span>
0070 
0071 subname = <span class="string">'fix_river_nodes'</span>;
0072 
0073 <span class="keyword">global</span> ftbverbose
0074 <span class="keyword">if</span> ftbverbose
0075     fprintf(<span class="string">'\nbegin : %s\n'</span>, subname)
0076 <span class="keyword">end</span>
0077 
0078 <span class="comment">% Check we actually have some rivers to process.</span>
0079 <span class="keyword">if</span> Mobj.nRivers &lt; 1
0080     warning(<span class="string">'No rivers specified in the domain.'</span>)
0081 
0082     <span class="keyword">if</span> ftbverbose
0083         fprintf(<span class="string">'end   : %s\n'</span>, subname)
0084     <span class="keyword">end</span>
0085     <span class="keyword">return</span>
0086 <span class="keyword">end</span>
0087 
0088 <span class="comment">% Remove nodes close to the open boundary joint with the coastline.</span>
0089 <span class="comment">% Identifying the coastline/open boundary joining nodes is simply a case of</span>
0090 <span class="comment">% taking the first and last node ID for each open boundary. Using that</span>
0091 <span class="comment">% position, we can find any river nodes which fall within that distance and</span>
0092 <span class="comment">% simply remove their data from the relevant Mobj.river_* arrays.</span>
0093 obc_land_nodes = nan(Mobj.nObs, 2);
0094 <span class="keyword">for</span> n = 1:Mobj.nObs
0095     obc_land_nodes(n, :) = [Mobj.read_obc_nodes{n}(1), <span class="keyword">...</span>
0096         Mobj.read_obc_nodes{n}(end)];
0097     <span class="keyword">for</span> d = 1:2
0098         [dist, idx] = sort(sqrt(<span class="keyword">...</span>
0099             (Mobj.lon(obc_land_nodes(n, d)) - Mobj.lon(Mobj.river_nodes)).^2 + <span class="keyword">...</span>
0100             (Mobj.lat(obc_land_nodes(n, d)) - Mobj.lat(Mobj.river_nodes)).^2 <span class="keyword">...</span>
0101             ));
0102         <span class="keyword">if</span> min(dist) &lt; dist_thresh
0103             <span class="comment">% Delete the positions with indices less than the threshold.</span>
0104             <span class="comment">% This could be more than one river node.</span>
0105             inds = find(dist &lt; dist_thresh);
0106             <span class="keyword">if</span> ftbverbose
0107                 <span class="comment">% Have to loop through the indices because fprint'ing a</span>
0108                 <span class="comment">% cell array (the river names) is tough...</span>
0109                 <span class="keyword">for</span> i = 1:length(inds)
0110                     fprintf(<span class="string">'Remove river %s at %.2f, %.2f\n'</span>, <span class="keyword">...</span>
0111                         Mobj.river_names{idx(inds(i))}, <span class="keyword">...</span>
0112                         Mobj.lon(Mobj.river_nodes(idx(inds(i)))), <span class="keyword">...</span>
0113                         Mobj.lat(Mobj.river_nodes(idx(inds(i)))))
0114                 <span class="keyword">end</span>
0115             <span class="keyword">end</span>
0116             Mobj.river_nodes(idx(inds)) = [];
0117             Mobj.river_flux(:, idx(inds)) = [];
0118             Mobj.river_names(idx(inds)) = [];
0119         <span class="keyword">end</span>
0120     <span class="keyword">end</span>
0121 <span class="keyword">end</span>
0122 
0123 clear obc_land_nodes n d dist idx inds
0124 
0125 <span class="comment">% For some of the rivers, the discharge is very large and is the source of</span>
0126 <span class="comment">% model instability (e.g. the Rhine crashes my irish_sea_v20 grid). So,</span>
0127 <span class="comment">% identify discharges in excess of some value and split that discharge over</span>
0128 <span class="comment">% adjacent elements, making sure they're still valid nodes and not used for</span>
0129 <span class="comment">% another river. Do this second so we don't have to worry about removing</span>
0130 <span class="comment">% nodes based on their distance from the land/open boundary joint which</span>
0131 <span class="comment">% have been split, which is the case if these two steps are reversed.</span>
0132 riv_idx = 1:size(Mobj.river_flux, 2);
0133 riv_idx = riv_idx(max(Mobj.river_flux) &gt; max_discharge);
0134 
0135 <span class="comment">% Find the appropriate nodes from the coastline nodes. This is mostly</span>
0136 <span class="comment">% lifted from get_EHYPE_rivers.m.</span>
0137 [~, ~, ~, bnd] = connectivity([Mobj.lon, Mobj.lat], Mobj.tri);
0138 boundary_nodes = 1:Mobj.nVerts;
0139 boundary_nodes = boundary_nodes(bnd);
0140 coast_nodes = boundary_nodes(~ismember(boundary_nodes, <span class="keyword">...</span>
0141     [Mobj.read_obc_nodes{:}]));
0142 clear boundary_nodes bnd
0143 
0144 <span class="comment">% Find all the nodes which are connected to two land nodes. These cause</span>
0145 <span class="comment">% problems with the search for valid river nodes. I can't think of an</span>
0146 <span class="comment">% elegant way of doing this, so brute force it is. This is a bit slow (~10</span>
0147 <span class="comment">% seconds) on my grid with ~13000 coastal nodes.</span>
0148 nogood = nan(size(coast_nodes)); <span class="comment">% clear out the nans later.</span>
0149 <span class="keyword">for</span> nn = 1:length(coast_nodes)
0150     [row, ~] = find(Mobj.tri == coast_nodes(nn));
0151     <span class="keyword">if</span> length(row) == 1
0152         nogood(nn) = coast_nodes(nn);
0153     <span class="keyword">end</span>
0154 <span class="keyword">end</span>
0155 nogood = nogood(~isnan(nogood));
0156 coast_nodes_valid = setdiff(coast_nodes, nogood);
0157 clear nn row nogood
0158 
0159 <span class="keyword">if</span> ftbverbose
0160     fprintf(<span class="string">'%i river(s) exceed the specified discharge threshold (%.2f m^{3}s^{-1}).\n'</span>, length(riv_idx), max_discharge)
0161 <span class="keyword">end</span>
0162 
0163 <span class="keyword">for</span> r = riv_idx
0164 
0165     <span class="comment">% Eliminate any existing river nodes from the list of candidates.</span>
0166     candidates = setdiff(coast_nodes_valid, Mobj.river_nodes);
0167 
0168     <span class="comment">% Extract the river data for the rivers in excess of the threshold so</span>
0169     <span class="comment">% we can remove them from the existing arrays.</span>
0170     river_flux = Mobj.river_flux(:, r);
0171     river_node = Mobj.river_nodes(r);
0172     river_names = Mobj.river_names(r);
0173     <span class="comment">% Replace the current time series with NaNs. We'll remove them to</span>
0174     <span class="comment">% after we've split the rivers in riv_idx. If we remove them here, then</span>
0175     <span class="comment">% the indices in riv_idx get offset by some amount (1 position each</span>
0176     <span class="comment">% time). Doing that is hard to track, so we'll replace with NaNs and</span>
0177     <span class="comment">% remove afterwards.</span>
0178     Mobj.river_flux(:, r) = nan;
0179     Mobj.river_nodes(r) = nan;
0180     Mobj.river_names{r} = <span class="string">'REMOVEME'</span>;
0181 
0182     <span class="comment">% Split the discharge based on the number of times the specified</span>
0183     <span class="comment">% maximum fits into the actual maximum. So, if the maximum is 10000</span>
0184     <span class="comment">% m^{3}s^{-1} and max_discharge is 2000 m^{3}s^{-1}, then you split</span>
0185     <span class="comment">% over 5 nodes.</span>
0186     nsplit = ceil(max(river_flux) / max_discharge);
0187 
0188     <span class="comment">% Scale the flux by nsplit.</span>
0189     river_flux = river_flux / nsplit;
0190 
0191     <span class="comment">% We can keep the original node, but we need to find the</span>
0192     <span class="comment">% remaining nsplit-1 nodes.</span>
0193     fv_obc = river_node;
0194     fv_names = {sprintf(<span class="string">'%s_%i'</span>, river_names{1}, 1)};
0195     fv_flow = repmat(river_flux, [1, nsplit]);
0196 
0197     <span class="keyword">for</span> ff = 2:nsplit
0198         <span class="comment">% Update the list of candidates to exclude those we've just found.</span>
0199         candidates = setdiff(candidates, fv_obc);
0200 
0201         [~, idx] = min(sqrt( <span class="keyword">...</span>
0202             (Mobj.lon(river_node) - Mobj.lon(candidates)).^2 + <span class="keyword">...</span>
0203             (Mobj.lat(river_node) - Mobj.lat(candidates)).^2));
0204 
0205         <span class="comment">% Now we can check if this node is an FVCOM-compatible one</span>
0206         <span class="comment">% (element of which it's a part has no more than one land</span>
0207         <span class="comment">% boundary).</span>
0208         [row, ~] = find(Mobj.tri == candidates(idx));
0209 
0210         <span class="keyword">if</span> length(row) == 1
0211             <span class="comment">% This is a bad node because it is a part of only one element.</span>
0212             <span class="comment">% The rivers need two adjacent elements to work reliably (?).</span>
0213             <span class="comment">% So, we need to repeat the process above until we find a node</span>
0214             <span class="comment">% that's connected to two elements. We'll try the other nodes</span>
0215             <span class="comment">% in the current element before searching the rest of the</span>
0216             <span class="comment">% coastline (which is computationally expensive).</span>
0217 
0218             <span class="comment">% Remove the current node index from the list of candidates</span>
0219             <span class="comment">% (i.e. leave only the two other nodes in the element).</span>
0220             mask = Mobj.tri(row, :) ~= candidates(idx);
0221             n_tri = Mobj.tri(row, mask);
0222 
0223             <span class="comment">% Remove values which aren't coastline values (we don't want to</span>
0224             <span class="comment">% set the river node to an open water node).</span>
0225             n_tri = intersect(n_tri, candidates);
0226 
0227             <span class="comment">% Of the remaining nodes in the element, find the closest one</span>
0228             <span class="comment">% to the original river location.</span>
0229             [~, n_idx] = sort(sqrt( <span class="keyword">...</span>
0230                 (Mobj.rivers.positions(r, 1) - Mobj.lon(n_tri)).^2 <span class="keyword">...</span>
0231                 + (Mobj.rivers.positions(r, 2) - Mobj.lon(n_tri)).^2));
0232 
0233             [row_2, ~] = find(Mobj.tri == n_tri(n_idx(1)));
0234             <span class="keyword">if</span> length(n_idx) &gt; 1
0235                 [row_3, ~] = find(Mobj.tri == n_tri(n_idx(2)));
0236             <span class="keyword">end</span>
0237             <span class="comment">% Closest first</span>
0238             <span class="keyword">if</span> length(row_2) &gt; 1
0239                 idx = find(candidates == n_tri(n_idx(1)));
0240                 <span class="comment">% The other one (only if we have more than one node to</span>
0241                 <span class="comment">% consider).</span>
0242             <span class="keyword">elseif</span> length(n_idx) &gt; 1 &amp;&amp; length(row_3) &gt; 1
0243                 idx = find(candidates == n_tri(n_idx(2)));
0244                 <span class="comment">% OK, we need to search across all the other coastline</span>
0245                 <span class="comment">% nodes.</span>
0246             <span class="keyword">else</span>
0247                 <span class="comment">% TODO: Implement a search of all the other coastline</span>
0248                 <span class="comment">% nodes. My testing indicates that we never get here (at</span>
0249                 <span class="comment">% least for the grids I've tested). I'd be interested to</span>
0250                 <span class="comment">% see the mesh which does get here...</span>
0251                 <span class="keyword">continue</span>
0252             <span class="keyword">end</span>
0253             fprintf(<span class="string">'alternate node '</span>)
0254         <span class="keyword">end</span>
0255 
0256         <span class="comment">% Update the node ID list and the river names list. The flux we've</span>
0257         <span class="comment">% already done because we know it's just river_flux/nsplit in</span>
0258         <span class="comment">% nsplit columns.</span>
0259         fv_obc(ff) = candidates(idx);
0260         fv_names{ff} = sprintf(<span class="string">'%s_%i'</span>, river_names{1}, ff);
0261     <span class="keyword">end</span>
0262 
0263     <span class="keyword">if</span> ftbverbose
0264         fprintf(<span class="string">'Split river %s over %i nodes.\n'</span>, river_names{1}, nsplit)
0265     <span class="keyword">end</span>
0266 
0267     <span class="comment">% Now we can append these new rivers to the existing list of</span>
0268     <span class="comment">% discharges, nodes and names.</span>
0269     Mobj.river_flux = [Mobj.river_flux, fv_flow];
0270     Mobj.river_names = [Mobj.river_names; fv_names'];
0271     Mobj.river_nodes = [Mobj.river_nodes, fv_obc];
0272 <span class="keyword">end</span>
0273 
0274 <span class="comment">% Remove all the original river fluxes for the split rivers. Check we're</span>
0275 <span class="comment">% doing the right columns by checking if the first row of the fluxes are</span>
0276 <span class="comment">% all NaNs for the riv_idx indices.</span>
0277 <span class="keyword">if</span> all(isnan(Mobj.river_flux(1, riv_idx)))
0278     Mobj.river_flux(:, riv_idx) = [];
0279     Mobj.river_nodes(riv_idx) = [];
0280     Mobj.river_names(riv_idx) = [];
0281 <span class="keyword">end</span>
0282 
0283 <span class="comment">% Tidy up.</span>
0284 clear r riv_idx river_flux river_nodes river_names nsplit <span class="keyword">...</span>
0285     boundary_nodes coast_nodes candidates fv_flow fv_dist <span class="keyword">...</span>
0286     fv_names fv_obc idx mask n_tri row ff
0287 
0288 <span class="keyword">if</span> ftbverbose
0289     fprintf(<span class="string">'end   : %s\n'</span>, subname)
0290 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Thu 18-Feb-2016 11:26:24 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>