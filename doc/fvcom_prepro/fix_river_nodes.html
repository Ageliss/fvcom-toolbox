<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of fix_river_nodes</title>
  <meta name="keywords" content="fix_river_nodes">
  <meta name="description" content="Takes the automatically identified river node positions generated by">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">fvcom_prepro</a> &gt; fix_river_nodes.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for fvcom_prepro&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>fix_river_nodes
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>Takes the automatically identified river node positions generated by</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function Mobj = fix_river_nodes(Mobj, max_discharge, dist_thresh, varargin) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> Takes the automatically identified river node positions generated by
 get_EHYPE_rivers or get_FVCOM_rivers and splits or removes them based on
 thresholds of discharge for the former and distance from the open
 boundary join with the coastline.

 Mobj = fix_river_nodes(Mobj)

 DESCRIPTION:
   The automatic identifcation of model nodes at which river inputs are
   discharged sometimes leads to problems with model stability.
   Specifically:
       1. Nodes very close to the open boundary join with the coastline
       can also cause high velocities to occur which if you have bounds
       checking enabled, will stop the model.
       2. Very large discharges into relatively small elements (e.g. the
       Rhine discharge) cause the model to crash.
       3. Rivers discharging into shallow elements can lead to
       instabilities.

   This function checks that:
       1. Rivers are deleted if their distance from the open boundary join
       with the coastline is less than the specified threshold.
       2. Any rivers with discharges above the specified threshold are
       split over a number of nodes such that each node has a maximum
       discharge less than the treshold.
       3. Optionally, each river is optimised to use the deepest node
       within ths distance threshold specified.
   This order is relatively important otherwise the splitting could put
   nodes within the land/open boundary joint radius and reduce the river
   discharge for a given river by eliminating only some of the river
   nodes.

 INPUT:
   Mobj - struct generated by get_EHYPE_rivers or get_FVCOM_rivers with
   the following fields:
       nVerts - number of nodes in the model domain
       nObs - number of open boundaries
       lon, lat - nodal positions in spherical coordinates
       tri - unstructured grid triangulation table
       read_obc_nodes - open boundary node IDs
       nRivers - number of rivers in the model domain
       river_nodes - currently identified river nodes
       river_names - currently identified river names
       river_flux - river discharge time series
   max_discharge - river discharge threshold above which rivers will be
       split over several nodes (in m^{3}s^{-1}).
   dist_thresh - distance from the open boundary nodes which connect with
       land within which nodes will be removed from the river data arrays.

   The following optional keyword-argument pairs are also supported:
   'depth_optimise' - set to true to search for the deepest node to use
       for the river within the distance threshold (dist_thresh)
       specified. This increases the stability of FVCOM. Defaults to
       false.
   'debug' - set to true to plot adjusted river nodes from the depth
       optimisation procedure. Defaults to false.

 OUTPUT:
   Mobj - struct with adjusted river_* fields listed above.

 TODO:
   - Check we don't split a river node into nodes which fall within the
   distance threshold for the land/open boundary joint.

 Author(s)
   Pierre Cazenave (Plymouth Marine Laboratory)

 Revision history:
   2013-12-13 First version based on the EHYPE section of my
   create_files_monthly.m script.
   2014-01-30 Fix a bug revealed when running this script on a larger
   model domain whereby the splitting of discharges across multiple
   nodes when a threshold discharge is exceeded didn't work if more than
   one river exceeded that threshold. Also add better exclusion of
   candidate river nodes (those with two land boundaries only are now
   excluded, as well as open ocean nodes and existing river nodes).
   2015-09-24 Add check for whether we actually have any rivers to
   process.
   2016-05-03 Update the number of rivers after fixing river nodes.
   2016-05-10 Add new option to pick the deepest node within the given
   radius. This is done after the splitting of river nodes but before the
   checks for a river input at a node connected to two land boundaries.
   This is because a river at a node with two land boundaries is always
   catastrophic, whereas a shallow node is sometimes catastrophic. This
   approach should also mean we minimise the risk of putting a node back
   onto a shallower node.
   2016-05-13 Move the removal of invalid coastline nodes into the
   function to read coastline nodes rather than having it in the splitting
   function.

==========================================================================</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function coast_nodes_valid = get_coastline(Mobj)</a></li><li><a href="#_sub2" class="code">function Mobj = clear_boundary_nodes(Mobj, dist_thresh, enames)</a></li><li><a href="#_sub3" class="code">function Mobj = split_big_rivers(Mobj, max_discharge, coast_nodes, enames, fnames)</a></li><li><a href="#_sub4" class="code">function Mobj = optimise_depth(Mobj, dist_thresh, coast_nodes, debug)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function Mobj = fix_river_nodes(Mobj, max_discharge, dist_thresh, varargin)</a>
0002 <span class="comment">% Takes the automatically identified river node positions generated by</span>
0003 <span class="comment">% get_EHYPE_rivers or get_FVCOM_rivers and splits or removes them based on</span>
0004 <span class="comment">% thresholds of discharge for the former and distance from the open</span>
0005 <span class="comment">% boundary join with the coastline.</span>
0006 <span class="comment">%</span>
0007 <span class="comment">% Mobj = fix_river_nodes(Mobj)</span>
0008 <span class="comment">%</span>
0009 <span class="comment">% DESCRIPTION:</span>
0010 <span class="comment">%   The automatic identifcation of model nodes at which river inputs are</span>
0011 <span class="comment">%   discharged sometimes leads to problems with model stability.</span>
0012 <span class="comment">%   Specifically:</span>
0013 <span class="comment">%       1. Nodes very close to the open boundary join with the coastline</span>
0014 <span class="comment">%       can also cause high velocities to occur which if you have bounds</span>
0015 <span class="comment">%       checking enabled, will stop the model.</span>
0016 <span class="comment">%       2. Very large discharges into relatively small elements (e.g. the</span>
0017 <span class="comment">%       Rhine discharge) cause the model to crash.</span>
0018 <span class="comment">%       3. Rivers discharging into shallow elements can lead to</span>
0019 <span class="comment">%       instabilities.</span>
0020 <span class="comment">%</span>
0021 <span class="comment">%   This function checks that:</span>
0022 <span class="comment">%       1. Rivers are deleted if their distance from the open boundary join</span>
0023 <span class="comment">%       with the coastline is less than the specified threshold.</span>
0024 <span class="comment">%       2. Any rivers with discharges above the specified threshold are</span>
0025 <span class="comment">%       split over a number of nodes such that each node has a maximum</span>
0026 <span class="comment">%       discharge less than the treshold.</span>
0027 <span class="comment">%       3. Optionally, each river is optimised to use the deepest node</span>
0028 <span class="comment">%       within ths distance threshold specified.</span>
0029 <span class="comment">%   This order is relatively important otherwise the splitting could put</span>
0030 <span class="comment">%   nodes within the land/open boundary joint radius and reduce the river</span>
0031 <span class="comment">%   discharge for a given river by eliminating only some of the river</span>
0032 <span class="comment">%   nodes.</span>
0033 <span class="comment">%</span>
0034 <span class="comment">% INPUT:</span>
0035 <span class="comment">%   Mobj - struct generated by get_EHYPE_rivers or get_FVCOM_rivers with</span>
0036 <span class="comment">%   the following fields:</span>
0037 <span class="comment">%       nVerts - number of nodes in the model domain</span>
0038 <span class="comment">%       nObs - number of open boundaries</span>
0039 <span class="comment">%       lon, lat - nodal positions in spherical coordinates</span>
0040 <span class="comment">%       tri - unstructured grid triangulation table</span>
0041 <span class="comment">%       read_obc_nodes - open boundary node IDs</span>
0042 <span class="comment">%       nRivers - number of rivers in the model domain</span>
0043 <span class="comment">%       river_nodes - currently identified river nodes</span>
0044 <span class="comment">%       river_names - currently identified river names</span>
0045 <span class="comment">%       river_flux - river discharge time series</span>
0046 <span class="comment">%   max_discharge - river discharge threshold above which rivers will be</span>
0047 <span class="comment">%       split over several nodes (in m^{3}s^{-1}).</span>
0048 <span class="comment">%   dist_thresh - distance from the open boundary nodes which connect with</span>
0049 <span class="comment">%       land within which nodes will be removed from the river data arrays.</span>
0050 <span class="comment">%</span>
0051 <span class="comment">%   The following optional keyword-argument pairs are also supported:</span>
0052 <span class="comment">%   'depth_optimise' - set to true to search for the deepest node to use</span>
0053 <span class="comment">%       for the river within the distance threshold (dist_thresh)</span>
0054 <span class="comment">%       specified. This increases the stability of FVCOM. Defaults to</span>
0055 <span class="comment">%       false.</span>
0056 <span class="comment">%   'debug' - set to true to plot adjusted river nodes from the depth</span>
0057 <span class="comment">%       optimisation procedure. Defaults to false.</span>
0058 <span class="comment">%</span>
0059 <span class="comment">% OUTPUT:</span>
0060 <span class="comment">%   Mobj - struct with adjusted river_* fields listed above.</span>
0061 <span class="comment">%</span>
0062 <span class="comment">% TODO:</span>
0063 <span class="comment">%   - Check we don't split a river node into nodes which fall within the</span>
0064 <span class="comment">%   distance threshold for the land/open boundary joint.</span>
0065 <span class="comment">%</span>
0066 <span class="comment">% Author(s)</span>
0067 <span class="comment">%   Pierre Cazenave (Plymouth Marine Laboratory)</span>
0068 <span class="comment">%</span>
0069 <span class="comment">% Revision history:</span>
0070 <span class="comment">%   2013-12-13 First version based on the EHYPE section of my</span>
0071 <span class="comment">%   create_files_monthly.m script.</span>
0072 <span class="comment">%   2014-01-30 Fix a bug revealed when running this script on a larger</span>
0073 <span class="comment">%   model domain whereby the splitting of discharges across multiple</span>
0074 <span class="comment">%   nodes when a threshold discharge is exceeded didn't work if more than</span>
0075 <span class="comment">%   one river exceeded that threshold. Also add better exclusion of</span>
0076 <span class="comment">%   candidate river nodes (those with two land boundaries only are now</span>
0077 <span class="comment">%   excluded, as well as open ocean nodes and existing river nodes).</span>
0078 <span class="comment">%   2015-09-24 Add check for whether we actually have any rivers to</span>
0079 <span class="comment">%   process.</span>
0080 <span class="comment">%   2016-05-03 Update the number of rivers after fixing river nodes.</span>
0081 <span class="comment">%   2016-05-10 Add new option to pick the deepest node within the given</span>
0082 <span class="comment">%   radius. This is done after the splitting of river nodes but before the</span>
0083 <span class="comment">%   checks for a river input at a node connected to two land boundaries.</span>
0084 <span class="comment">%   This is because a river at a node with two land boundaries is always</span>
0085 <span class="comment">%   catastrophic, whereas a shallow node is sometimes catastrophic. This</span>
0086 <span class="comment">%   approach should also mean we minimise the risk of putting a node back</span>
0087 <span class="comment">%   onto a shallower node.</span>
0088 <span class="comment">%   2016-05-13 Move the removal of invalid coastline nodes into the</span>
0089 <span class="comment">%   function to read coastline nodes rather than having it in the splitting</span>
0090 <span class="comment">%   function.</span>
0091 <span class="comment">%</span>
0092 <span class="comment">%==========================================================================</span>
0093 
0094 [~, subname] = fileparts(mfilename(<span class="string">'fullpath'</span>));
0095 
0096 <span class="keyword">global</span> ftbverbose
0097 <span class="keyword">if</span> ftbverbose
0098     fprintf(<span class="string">'\nbegin : %s\n'</span>, subname)
0099 <span class="keyword">end</span>
0100 
0101 depth_optimise = false;
0102 debug = false;
0103 <span class="keyword">for</span> aa = 1:2:length(varargin)
0104     <span class="keyword">switch</span> varargin{aa}
0105         <span class="keyword">case</span> <span class="string">'depth_optimise'</span>
0106             depth_optimise = varargin{aa + 1};
0107         <span class="keyword">case</span> <span class="string">'debug'</span>
0108             debug = varargin{aa + 1};
0109     <span class="keyword">end</span>
0110 <span class="keyword">end</span>
0111 
0112 <span class="comment">% Check we actually have some rivers to process.</span>
0113 <span class="keyword">if</span> Mobj.nRivers &lt; 1
0114     warning(<span class="string">'No rivers specified in the domain.'</span>)
0115 
0116     <span class="keyword">if</span> ftbverbose
0117         fprintf(<span class="string">'end   : %s\n'</span>, subname)
0118     <span class="keyword">end</span>
0119     <span class="keyword">return</span>
0120 <span class="keyword">end</span>
0121 
0122 <span class="comment">% Generate names for the variables we're going to use. These may not all be</span>
0123 <span class="comment">% used if you are not running ERSEM, but we build them in case.</span>
0124 evars = {<span class="string">'flux'</span>, <span class="string">'temp'</span>, <span class="string">'salt'</span>, <span class="string">'nh4'</span>, <span class="string">'no3'</span>, <span class="string">'o'</span>, <span class="string">'p'</span>, <span class="string">'sio3'</span>, <span class="string">'dic'</span>, <span class="string">'bioalk'</span>};
0125 enames = cell(length(evars));
0126 fnames = cell(length(evars));
0127 <span class="keyword">for</span> e = 1:length(evars)
0128     enames{e} = sprintf(<span class="string">'river_%s'</span>, evars{e});
0129     fnames{e} = sprintf(<span class="string">'fv_%s'</span>, evars{e});
0130 <span class="keyword">end</span>
0131 
0132 <span class="comment">% Find the model coastline.</span>
0133 coast_nodes = <a href="#_sub1" class="code" title="subfunction coast_nodes_valid = get_coastline(Mobj)">get_coastline</a>(Mobj);
0134 
0135 <span class="comment">% Remove river nodes close to the open boundaries.</span>
0136 Mobj = <a href="#_sub2" class="code" title="subfunction Mobj = clear_boundary_nodes(Mobj, dist_thresh, enames)">clear_boundary_nodes</a>(Mobj, dist_thresh, enames);
0137 
0138 <span class="comment">% Split big rivers over adjacent nodes.</span>
0139 Mobj = <a href="#_sub3" class="code" title="subfunction Mobj = split_big_rivers(Mobj, max_discharge, coast_nodes, enames, fnames)">split_big_rivers</a>(Mobj, max_discharge, coast_nodes, enames, fnames);
0140 
0141 <span class="comment">% If we've been asked to optimise the depth of nodes, do that now. We may</span>
0142 <span class="comment">% have to rerun some of the checks above. I don't know yet.</span>
0143 <span class="keyword">if</span> depth_optimise
0144     Mobj = <a href="#_sub4" class="code" title="subfunction Mobj = optimise_depth(Mobj, dist_thresh, coast_nodes, debug)">optimise_depth</a>(Mobj, dist_thresh, coast_nodes, debug);
0145 <span class="keyword">end</span>
0146 
0147 <span class="comment">% Update the number of rivers we have.</span>
0148 Mobj.nRivers = length(Mobj.river_nodes);
0149 
0150 <span class="keyword">if</span> ftbverbose
0151     fprintf(<span class="string">'end   : %s\n'</span>, subname)
0152 <span class="keyword">end</span>
0153 
0154 <a name="_sub1" href="#_subfunctions" class="code">function coast_nodes_valid = get_coastline(Mobj)</a>
0155 <span class="comment">% Find the appropriate nodes from the coastline nodes. This is mostly</span>
0156 <span class="comment">% lifted from get_EHYPE_rivers.m.</span>
0157 [~, ~, ~, bnd] = connectivity([Mobj.lon, Mobj.lat], Mobj.tri);
0158 boundary_nodes = 1:Mobj.nVerts;
0159 boundary_nodes = boundary_nodes(bnd);
0160 coast_nodes = boundary_nodes(~ismember(boundary_nodes, <span class="keyword">...</span>
0161     [Mobj.read_obc_nodes{:}]));
0162 
0163 <span class="comment">% Remove invalid coastline nodes (from the perspective of rivers). Those</span>
0164 <span class="comment">% are which are connected to two land nodes. I can't think of an elegant</span>
0165 <span class="comment">% way of doing this, so brute force it is. This is a bit slow (~10 seconds)</span>
0166 <span class="comment">% on my grid with ~13000 coastal nodes.</span>
0167 nogood = nan(size(coast_nodes)); <span class="comment">% clear out the nans later.</span>
0168 <span class="keyword">for</span> nn = 1:length(coast_nodes)
0169     [row, ~] = find(Mobj.tri == coast_nodes(nn));
0170     <span class="keyword">if</span> length(row) == 1
0171         nogood(nn) = coast_nodes(nn);
0172     <span class="keyword">end</span>
0173 <span class="keyword">end</span>
0174 nogood = nogood(~isnan(nogood));
0175 coast_nodes_valid = setdiff(coast_nodes, nogood);
0176 
0177 
0178 <a name="_sub2" href="#_subfunctions" class="code">function Mobj = clear_boundary_nodes(Mobj, dist_thresh, enames)</a>
0179 <span class="comment">% Remove nodes close to the open boundary joint with the coastline.</span>
0180 <span class="comment">% Identifying the coastline/open boundary joining nodes is simply a case of</span>
0181 <span class="comment">% taking the first and last node ID for each open boundary. Using that</span>
0182 <span class="comment">% position, we can find any river nodes which fall within that distance and</span>
0183 <span class="comment">% simply remove their data from the relevant Mobj.river_* arrays.</span>
0184 
0185 <span class="keyword">global</span> ftbverbose
0186 
0187 obc_land_nodes = nan(Mobj.nObs, 2);
0188 <span class="keyword">for</span> n = 1:Mobj.nObs
0189     obc_land_nodes(n, :) = [Mobj.read_obc_nodes{n}(1), <span class="keyword">...</span>
0190         Mobj.read_obc_nodes{n}(end)];
0191     <span class="keyword">for</span> d = 1:2
0192         [dist, idx] = sort(sqrt(<span class="keyword">...</span>
0193             (Mobj.lon(obc_land_nodes(n, d)) - Mobj.lon(Mobj.river_nodes)).^2 + <span class="keyword">...</span>
0194             (Mobj.lat(obc_land_nodes(n, d)) - Mobj.lat(Mobj.river_nodes)).^2 <span class="keyword">...</span>
0195             ));
0196         <span class="keyword">if</span> min(dist) &lt; dist_thresh
0197             <span class="comment">% Delete the positions with indices less than the threshold.</span>
0198             <span class="comment">% This could be more than one river node.</span>
0199             inds = find(dist &lt; dist_thresh);
0200             <span class="keyword">if</span> ftbverbose
0201                 <span class="comment">% Have to loop through the indices because fprint'ing a</span>
0202                 <span class="comment">% cell array (the river names) is tough...</span>
0203                 <span class="keyword">for</span> i = 1:length(inds)
0204                     fprintf(<span class="string">'Remove river %s at %.2f, %.2f\n'</span>, <span class="keyword">...</span>
0205                         Mobj.river_names{idx(inds(i))}, <span class="keyword">...</span>
0206                         Mobj.lon(Mobj.river_nodes(idx(inds(i)))), <span class="keyword">...</span>
0207                         Mobj.lat(Mobj.river_nodes(idx(inds(i)))))
0208                 <span class="keyword">end</span>
0209             <span class="keyword">end</span>
0210             Mobj.river_nodes(idx(inds)) = [];
0211             Mobj.river_flux(:, idx(inds)) = [];
0212             Mobj.river_names(idx(inds)) = [];
0213             <span class="comment">% Also trim the temperature, salinity and ERSEM variables,</span>
0214             <span class="comment">% if we have them.</span>
0215             <span class="keyword">for</span> e = 1:length(enames)
0216                 <span class="keyword">if</span> isfield(Mobj, enames{e})
0217                     Mobj.(enames{e})(:, idx(inds)) = [];
0218                 <span class="keyword">end</span>
0219             <span class="keyword">end</span>
0220         <span class="keyword">end</span>
0221     <span class="keyword">end</span>
0222 <span class="keyword">end</span>
0223 
0224 <a name="_sub3" href="#_subfunctions" class="code">function Mobj = split_big_rivers(Mobj, max_discharge, coast_nodes, enames, fnames)</a>
0225 <span class="comment">% For some of the rivers, the discharge is very large and is the source of</span>
0226 <span class="comment">% model instability (e.g. the Rhine crashes my irish_sea_v20 grid). So,</span>
0227 <span class="comment">% identify discharges in excess of some value and split that discharge over</span>
0228 <span class="comment">% adjacent elements, making sure they're still valid nodes and not used for</span>
0229 <span class="comment">% another river. Do this second so we don't have to worry about removing</span>
0230 <span class="comment">% nodes based on their distance from the land/open boundary joint which</span>
0231 <span class="comment">% have been split, which is the case if these two steps are reversed.</span>
0232 
0233 <span class="keyword">global</span> ftbverbose
0234 
0235 riv_idx = 1:size(Mobj.river_flux, 2);
0236 riv_idx = riv_idx(max(Mobj.river_flux) &gt; max_discharge);
0237 
0238 <span class="keyword">if</span> ftbverbose
0239     fprintf(<span class="string">'%i river(s) exceed the specified discharge threshold (%.2f m^{3}s^{-1}).\n'</span>, length(riv_idx), max_discharge)
0240 <span class="keyword">end</span>
0241 
0242 <span class="keyword">for</span> r = riv_idx
0243     <span class="comment">% Based on the flux data, find adjacent nodes over which to split the</span>
0244     <span class="comment">% data and then split all variables (both physics and, optionally,</span>
0245     <span class="comment">% ERSEM data).</span>
0246 
0247     <span class="comment">% Eliminate any existing river nodes from the list of candidates.</span>
0248     candidates = setdiff(coast_nodes, Mobj.river_nodes);
0249 
0250     <span class="comment">% Extract the river data for the rivers in excess of the threshold so</span>
0251     <span class="comment">% we can remove them from the existing arrays.</span>
0252     <span class="keyword">for</span> e = 1:length(enames)
0253         <span class="keyword">if</span> isfield(Mobj, enames{e})
0254             tmp_struct.(enames{e}) = Mobj.(enames{e})(:, r);
0255         <span class="keyword">end</span>
0256     <span class="keyword">end</span>
0257 
0258     <span class="comment">% Save the nodes and names of this river.</span>
0259     river_node = Mobj.river_nodes(r);
0260     river_names = Mobj.river_names(r);
0261 
0262     <span class="comment">% Replace the current time series with NaNs. We'll remove them after</span>
0263     <span class="comment">% we've split the rivers in riv_idx. If we remove them here, then the</span>
0264     <span class="comment">% indices in riv_idx get offset by some amount (1 position each time).</span>
0265     <span class="comment">% Doing that is hard to track, so we'll replace with NaNs and remove</span>
0266     <span class="comment">% afterwards.</span>
0267     <span class="keyword">for</span> e = 1:length(enames)
0268         <span class="keyword">if</span> isfield(Mobj, enames{e})
0269             Mobj.(enames{e})(:, r) = nan;
0270         <span class="keyword">end</span>
0271     <span class="keyword">end</span>
0272     Mobj.river_nodes(r) = nan;
0273     Mobj.river_names{r} = <span class="string">'REMOVEME'</span>;
0274 
0275     <span class="comment">% Split the discharge based on the number of times the specified</span>
0276     <span class="comment">% maximum fits into the actual maximum. So, if the maximum is 10000</span>
0277     <span class="comment">% m^{3}s^{-1} and max_discharge is 2000 m^{3}s^{-1}, then you split</span>
0278     <span class="comment">% over 5 nodes.</span>
0279     nsplit = ceil(max(tmp_struct.river_flux) / max_discharge);
0280 
0281     <span class="comment">% Scale the data by nsplit.</span>
0282     <span class="keyword">for</span> e = 1:length(enames)
0283         <span class="keyword">if</span> isfield(Mobj, enames{e})
0284             tmp_struct.(enames{e}) = tmp_struct.(enames{e}) / nsplit;
0285         <span class="keyword">end</span>
0286     <span class="keyword">end</span>
0287 
0288     <span class="comment">% We can keep the original node, but we need to find the</span>
0289     <span class="comment">% remaining nsplit-1 nodes.</span>
0290     fv_obc = river_node;
0291     fv_names = {sprintf(<span class="string">'%s_%i'</span>, river_names{1}, 1)};
0292     <span class="keyword">for</span> e = 1:length(fnames)
0293         <span class="keyword">if</span> isfield(Mobj, enames{e})
0294             tmp_struct.(fnames{e}) = repmat(tmp_struct.(enames{e}), [1, nsplit]);
0295         <span class="keyword">end</span>
0296     <span class="keyword">end</span>
0297 
0298     <span class="keyword">for</span> ff = 2:nsplit
0299         <span class="comment">% Update the list of candidates to exclude those we've just found.</span>
0300         candidates = setdiff(candidates, fv_obc);
0301 
0302         [~, idx] = min(sqrt( <span class="keyword">...</span>
0303             (Mobj.lon(river_node) - Mobj.lon(candidates)).^2 + <span class="keyword">...</span>
0304             (Mobj.lat(river_node) - Mobj.lat(candidates)).^2));
0305 
0306         <span class="comment">% Now we can check if this node is an FVCOM-compatible one</span>
0307         <span class="comment">% (element of which it's a part has no more than one land</span>
0308         <span class="comment">% boundary).</span>
0309         [row, ~] = find(Mobj.tri == candidates(idx));
0310 
0311         <span class="keyword">if</span> length(row) == 1
0312             <span class="comment">% This is a bad node because it is a part of only one element.</span>
0313             <span class="comment">% The rivers need two adjacent elements to work reliably (?).</span>
0314             <span class="comment">% So, we need to repeat the process above until we find a node</span>
0315             <span class="comment">% that's connected to two elements. We'll try the other nodes</span>
0316             <span class="comment">% in the current element before searching the rest of the</span>
0317             <span class="comment">% coastline (which is computationally expensive).</span>
0318 
0319             <span class="comment">% Remove the current node index from the list of candidates</span>
0320             <span class="comment">% (i.e. leave only the two other nodes in the element).</span>
0321             mask = Mobj.tri(row, :) ~= candidates(idx);
0322             n_tri = Mobj.tri(row, mask);
0323 
0324             <span class="comment">% Remove values which aren't coastline values (we don't want to</span>
0325             <span class="comment">% set the river node to an open water node).</span>
0326             n_tri = intersect(n_tri, candidates);
0327 
0328             <span class="comment">% Of the remaining nodes in the element, find the closest one</span>
0329             <span class="comment">% to the original river location.</span>
0330             [~, n_idx] = sort(sqrt( <span class="keyword">...</span>
0331                 (Mobj.rivers.positions(r, 1) - Mobj.lon(n_tri)).^2 <span class="keyword">...</span>
0332                 + (Mobj.rivers.positions(r, 2) - Mobj.lon(n_tri)).^2));
0333 
0334             [row_2, ~] = find(Mobj.tri == n_tri(n_idx(1)));
0335             <span class="keyword">if</span> length(n_idx) &gt; 1
0336                 [row_3, ~] = find(Mobj.tri == n_tri(n_idx(2)));
0337             <span class="keyword">end</span>
0338             <span class="comment">% Closest first</span>
0339             <span class="keyword">if</span> length(row_2) &gt; 1
0340                 idx = find(candidates == n_tri(n_idx(1)));
0341                 <span class="comment">% The other one (only if we have more than one node to</span>
0342                 <span class="comment">% consider).</span>
0343             <span class="keyword">elseif</span> length(n_idx) &gt; 1 &amp;&amp; length(row_3) &gt; 1
0344                 idx = find(candidates == n_tri(n_idx(2)));
0345                 <span class="comment">% OK, we need to search across all the other coastline</span>
0346                 <span class="comment">% nodes.</span>
0347             <span class="keyword">else</span>
0348                 <span class="comment">% TODO: Implement a search of all the other coastline</span>
0349                 <span class="comment">% nodes. My testing indicates that we never get here (at</span>
0350                 <span class="comment">% least for the grids I've tested). I'd be interested to</span>
0351                 <span class="comment">% see the mesh which does get here...</span>
0352                 <span class="keyword">continue</span>
0353             <span class="keyword">end</span>
0354             fprintf(<span class="string">'alternate node '</span>)
0355         <span class="keyword">end</span>
0356 
0357         <span class="comment">% Update the node ID list and the river names list. The flux we've</span>
0358         <span class="comment">% already done because we know it's just river_flux/nsplit in</span>
0359         <span class="comment">% nsplit columns.</span>
0360         fv_obc(ff) = candidates(idx);
0361         fv_names{ff} = sprintf(<span class="string">'%s_%i'</span>, river_names{1}, ff);
0362     <span class="keyword">end</span>
0363 
0364     <span class="keyword">if</span> ftbverbose
0365         fprintf(<span class="string">'Split river %s over %i nodes.\n'</span>, river_names{1}, nsplit)
0366     <span class="keyword">end</span>
0367 
0368     <span class="comment">% Now we can append these new rivers to the existing list of</span>
0369     <span class="comment">% discharges, nodes and names.</span>
0370     <span class="keyword">for</span> e = 1:length(enames)
0371         <span class="keyword">if</span> isfield(Mobj, enames{e})
0372             Mobj.(enames{e}) = [Mobj.(enames{e}), tmp_struct.(fnames{e})];
0373         <span class="keyword">end</span>
0374     <span class="keyword">end</span>
0375     Mobj.river_names = [Mobj.river_names; fv_names'];
0376     Mobj.river_nodes = [Mobj.river_nodes, fv_obc];
0377 <span class="keyword">end</span>
0378 
0379 <span class="comment">% Remove all the original river data for the split rivers. Check we're</span>
0380 <span class="comment">% doing the right columns by checking if the first row of the fluxes are</span>
0381 <span class="comment">% all NaNs for the riv_idx indices.</span>
0382 <span class="keyword">if</span> all(isnan(Mobj.river_flux(1, riv_idx)))
0383     <span class="keyword">for</span> e = 1:length(enames)
0384         <span class="keyword">if</span> isfield(Mobj, enames{e})
0385             Mobj.(enames{e})(:, riv_idx) = [];
0386         <span class="keyword">end</span>
0387     <span class="keyword">end</span>
0388     Mobj.river_nodes(riv_idx) = [];
0389     Mobj.river_names(riv_idx) = [];
0390 <span class="keyword">end</span>
0391 
0392 <a name="_sub4" href="#_subfunctions" class="code">function Mobj = optimise_depth(Mobj, dist_thresh, coast_nodes, debug)</a>
0393 <span class="comment">% For each river node, search within the distance threshold given and pick</span>
0394 <span class="comment">% the deepest coastline node for that river.</span>
0395 
0396 <span class="keyword">global</span> ftbverbose
0397 
0398 coast_depth = Mobj.h(coast_nodes);
0399 coast_lon = Mobj.lon(coast_nodes);
0400 coast_lat = Mobj.lat(coast_nodes);
0401 
0402 <span class="keyword">for</span> r = 1:length(Mobj.river_nodes)
0403 
0404     <span class="comment">% The current river index in the global arrays.</span>
0405     ri = Mobj.river_nodes(r);
0406 
0407     <span class="comment">% Find the nearest nodes.</span>
0408     [distance, candidates] = sort(sqrt((coast_lon - Mobj.lon(ri)).^2 + <span class="keyword">...</span>
0409         (coast_lat - Mobj.lat(ri)).^2));
0410     candidate_nodes = candidates(distance &lt; dist_thresh);
0411     <span class="comment">% Find the deepest node within the search radius.</span>
0412     [deepest_depth, deepest_index] = max(coast_depth(candidates(distance &lt; dist_thresh)));
0413     <span class="comment">% Update if we've deepened this node.</span>
0414     <span class="keyword">if</span> ri ~= candidate_nodes(deepest_index)
0415         <span class="comment">% Only update if we improve matters (deepen a river input node).</span>
0416         <span class="keyword">if</span> deepest_depth &gt; Mobj.h(ri)
0417             <span class="comment">% Let everyone know what's going on.</span>
0418             <span class="keyword">if</span> ftbverbose
0419                 fprintf([<span class="string">'Moving river %s to a node with depth %.2f'</span>, <span class="keyword">...</span>
0420                     <span class="string">' from one with a depth of %.2f (%.2fm deeper).\n'</span>], <span class="keyword">...</span>
0421                     Mobj.river_names{r}, <span class="keyword">...</span>
0422                     Mobj.h(coast_nodes(candidate_nodes(deepest_index))), <span class="keyword">...</span>
0423                     Mobj.h(Mobj.river_nodes(r)), <span class="keyword">...</span>
0424                     Mobj.h(coast_nodes(candidate_nodes(deepest_index))) - Mobj.h(ri))
0425             <span class="keyword">end</span>
0426 
0427             <span class="comment">% Update the mesh object.</span>
0428             Mobj.river_nodes(r) = coast_nodes(candidate_nodes(deepest_index));
0429 
0430             <span class="keyword">if</span> debug
0431                 figure(1)
0432                 clf
0433                 triplot(Mobj.tri, Mobj.lon, Mobj.lat, <span class="string">'k'</span>)
0434                 hold on
0435                 plot(coast_lon, coast_lat, <span class="string">'r.'</span>)
0436                 scatter(coast_lon(candidates(distance &lt; dist_thresh)), <span class="keyword">...</span>
0437                     coast_lat(candidates(distance &lt; dist_thresh)), <span class="keyword">...</span>
0438                     30, <span class="keyword">...</span>
0439                     -coast_depth(candidates(distance &lt; dist_thresh)), <span class="keyword">...</span>
0440                     <span class="string">'filled'</span>)
0441                 colorbar
0442                 plot(Mobj.lon(ri), Mobj.lat(ri), <span class="string">'r^'</span>, <span class="string">'MarkerSize'</span>, 20)
0443                 plot(coast_lon(candidate_nodes(deepest_index)), <span class="keyword">...</span>
0444                     coast_lat(candidate_nodes(deepest_index)), <span class="keyword">...</span>
0445                     <span class="string">'b^'</span>, <span class="keyword">...</span>
0446                     <span class="string">'MarkerSize'</span>, 20)
0447                 axis(<span class="string">'tight'</span>, <span class="string">'equal'</span>)
0448                 legend(<span class="string">'grid'</span>, <span class="string">'coastline'</span>, <span class="string">'depths'</span>, <span class="string">'original'</span>, <span class="string">'new'</span>)
0449                 legend(<span class="string">'BoxOff'</span>)
0450                 xlim([Mobj.lon(ri) - dist_thresh * 2, Mobj.lon(ri) + dist_thresh * 2])
0451                 ylim([Mobj.lat(ri) - dist_thresh * 2, Mobj.lat(ri) + dist_thresh * 2])
0452                 fprintf(<span class="string">'Press any key to continue... \n'</span>)
0453                 pause
0454             <span class="keyword">end</span>
0455         <span class="keyword">else</span>
0456             <span class="keyword">continue</span>
0457         <span class="keyword">end</span>
0458     <span class="keyword">end</span>
0459 <span class="keyword">end</span>
0460 <span class="keyword">if</span> ftbverbose
0461     fprintf(<span class="string">'Minimum river depth is: %.2f\n'</span>, min(Mobj.h(Mobj.river_nodes)))
0462 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Wed 10-Aug-2016 16:44:39 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>